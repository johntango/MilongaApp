<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Milonga Planner (SPA)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="style.css" />
  </head>
  <body>
    <header>
      <h1>Milonga Planner (T-T-V-T-T-M)</h1>
      <div class="controls">
        <input id="pl-name" placeholder="Playlist name‚Ä¶" style="width: 220px" />

        <button id="pl-save">Save</button>
        <select id="pl-list">
          <option value="">‚Äî saved playlists ‚Äî</option>
        </select>
        <button id="pl-refresh">Refresh</button>
        <button id="pl-load">Load</button>
        <button id="pl-delete" title="Delete selected playlist">Delete</button>

        <div class="separator">|</div>
        <label class="muted">Tanda Library:</label>
        <select id="tanda-list">
          <option value="">‚Äî saved tandas ‚Äî</option>
        </select>
        <button id="tanda-refresh" title="Refresh tanda library">üîÑ</button>
        <button id="tanda-delete" title="Delete selected tanda">üóëÔ∏è</button>

        <label class="muted">Target:</label>
        <select id="minutes">
          <option value="180" selected>180 min</option>
          <option value="150">150 min</option>
          <option value="210">210 min</option>
        </select>
        <label for="scheduleSelect">Tanda Styles:</label>
        <select id="scheduleSelect" value="tandaScheduleClassic.json">
          <option value="tandaScheduleStandard.json">Standard</option>
          <option value="tandaScheduleClassic.json">Classic</option>
          <option value="tandaScheduleModern.json">Modern</option>
          <option value="tandaScheduleRich.json">Rich</option>
        </select>
        <ul id="tandas"></ul>
        <div id="summary"></div>
        <button id="tanda-gen">Generate Tandas (stream)</button>
        <button id="review">Agent Review</button>
        <button id="swap">Swap</button>
        <button id="next">Next Track</button>
        <button id="pause">Play/Pause</button>
      </div>
      <label class="muted">Tango genre:</label>
      <select id="tango-genre">
        <option value="auto" selected>Auto (neighbor)</option>
        <option value="tango-genre">Tango</option>
        <option value="vieja">Vieja</option>
        <option value="nueva">Nueva</option>
        <option value="golden">Golden</option>
        <option value="renaissence">Renaisence</option>
      </select>
      <label class="muted">Cortina genre:</label>
      <select id="cortina-genre">
        <option value="auto" selected>Auto (neighbor)</option>
        <option value="jazz">Jazz</option>
        <option value="rock">Rock</option>
        <option value="country">Country</option>
        <option value="blues">Blues</option>
      </select>
      <span
        id="cortina-mode-indicator"
        class="muted"
        style="font-size: 0.8em; margin-left: 4px"
        >Mode: Planning</span
      >
    </header>
    <span id="status-badge" class="badge" title="Background activity"
      >Idle</span
    >
    <div class="page">
      <div class="panel">
        <div class="row"><strong>Now Playing</strong></div>
        <div id="now" class="muted">‚Äì</div>
        <div class="space"></div>
        <audio id="player" controls preload="none"></audio>
        <div class="space"></div>
        <div class="grid2">
          <div>
            <small class="muted">Elapsed</small>
            <div id="elapsed">0:00</div>
          </div>
          <div>
            <small class="muted">Remaining</small>
            <div id="remaining">0:00</div>
          </div>
        </div>
        <div class="space"></div>
        <div class="footer">
          <small class="muted">End by:</small>
          <div id="eta" class="muted">‚Äì</div>
        </div>
        <div class="row">
          <strong>Activity</strong>
          <button class="tiny" id="log-clear">Clear</button>
        </div>
        <div id="activity-log" class="log"></div>

        <div class="space"></div>
        <div class="row">
          <strong>Orchestra Search</strong>
          <button class="tiny" id="orchestra-clear">Clear</button>
        </div>
        <div class="row">
          <input
            type="text"
            id="orchestra-search"
            placeholder="Search by orchestra name..."
            style="width: 100%; margin-bottom: 8px"
          />
        </div>
        <div
          id="orchestra-results"
          class="log"
          style="max-height: 200px; display: none"
        >
          <div
            id="orchestra-count"
            class="muted"
            style="margin-bottom: 8px"
          ></div>
          <div id="orchestra-tracks" style="font-size: 0.9em"></div>
        </div>

        <div class="space"></div>
        <div class="row">
          <strong>LLM Transcript</strong>
          <button class="tiny" id="llm-clear">Clear</button>
        </div>
        <pre id="llm-transcript" class="log llm"></pre>
      </div>

      <div class="panel">
        <div class="row">
          <strong>Plan</strong><span id="total" class="muted"></span>
        </div>
        <div id="timeline" class="timeline"></div>
      </div>
    </div>

    <script>
      // ---------- DOM helpers ----------
      const $ = (sel) => document.querySelector(sel);
      const timelineEl = $("#timeline");
      const player = $("#player");
      const nowEl = $("#now");
      const totalEl = $("#total");
      const elapsedEl = $("#elapsed");
      const remainingEl = $("#remaining");
      const etaEl = $("#eta");
      const tandasListEl = $("#tandas");
      const summaryEl = $("#summary");
      const cortinaGenreSel = $("#cortina-genre");
      const tangoGenreSel = $("#tango-genre");
      const cortinaModeIndicator = $("#cortina-mode-indicator");

      let PLAN = null; // current plan { tandas: [...] }
      let curIdx = -1; // index into plan.tandas[*]
      let curTrackOffset = 0;
      let swapFirst = null;

      let viewerWin = null;

      // Track current replacement session to avoid repetition within the same replacement attempt
      let currentReplacementSession = null; // { tandaIndex, trackIndex, attempted: Set() }

      // Update cortina mode indicator based on current state
      function updateCortinaModeIndicator() {
        // Defensive check - ensure elements exist
        if (!cortinaModeIndicator || !cortinaGenreSel) {
          console.debug("[CORTINA] Mode indicator elements not ready yet");
          return;
        }

        const isPlaylistActive =
          PLAN && Array.isArray(PLAN.tandas) && PLAN.tandas.length > 0;
        const selectedGenre = cortinaGenreSel.value || "auto";

        if (isPlaylistActive) {
          if (selectedGenre === "auto") {
            cortinaModeIndicator.textContent = "Mode: Auto (replacing)";
            cortinaModeIndicator.style.color = "#666";
          } else {
            cortinaModeIndicator.textContent = `Mode: ${selectedGenre} (replacing)`;
            cortinaModeIndicator.style.color = "#0066cc";
          }
        } else {
          if (selectedGenre === "auto") {
            cortinaModeIndicator.textContent = "Mode: Auto (planning)";
            cortinaModeIndicator.style.color = "#666";
          } else {
            cortinaModeIndicator.textContent = `Mode: ${selectedGenre} (planning)`;
            cortinaModeIndicator.style.color = "#0066cc";
          }
        }
      }

      // Add event listener for cortina genre dropdown
      if (cortinaGenreSel) {
        cortinaGenreSel.addEventListener("change", () => {
          updateCortinaModeIndicator();
          console.log(
            `[CORTINA] Genre selection changed to: ${cortinaGenreSel.value}`
          );
        });
      }

      function clearReplacementHistory() {
        currentReplacementSession = null;
        console.log("[REPLACEMENT] Session cleared for new plan");
      }

      function clearReplacementSession() {
        if (currentReplacementSession) {
          console.log(
            `[REPLACEMENT] Manually clearing session for ${currentReplacementSession.tandaIndex}:${currentReplacementSession.trackIndex}`
          );
          currentReplacementSession = null;
        }
      }

      function getReplacementSession(tandaIndex, trackIndex) {
        // If this is a different position than the current session, start fresh
        if (
          !currentReplacementSession ||
          currentReplacementSession.tandaIndex !== tandaIndex ||
          currentReplacementSession.trackIndex !== trackIndex
        ) {
          if (currentReplacementSession) {
            console.log(
              `[REPLACEMENT] Switching from session ${currentReplacementSession.tandaIndex}:${currentReplacementSession.trackIndex} (${currentReplacementSession.attempted.size} attempted) to ${tandaIndex}:${trackIndex}`
            );
          } else {
            console.log(
              `[REPLACEMENT] Starting new session for ${tandaIndex}:${trackIndex}`
            );
          }

          currentReplacementSession = {
            tandaIndex,
            trackIndex,
            attempted: new Set(),
          };
        }
        return currentReplacementSession;
      }
      // load all tracks from catalog-Art.json
      fetch("/api/catalog/full")
        .then((res) => {
          if (!res.ok) throw new Error("Failed to fetch full catalog");
          return res.json();
        })
        .then((data) => {
          window.catalogArt = { tracks: data };
          console.log("Loaded full catalog:", data.length, "tracks");
        })
        .catch((err) => {
          console.error("Error loading catalog from API:", err);
        });

      const state = { loadedScheduleSlots: null };

      document
        .getElementById("scheduleSelect")
        .addEventListener("change", async (e) => {
          state.loadedScheduleSlots = null;
          const url = `schedules/${e.target.value}`;
          if (!url) return;

          const data = await (await fetch(url)).json();
          // Accept two shapes:
          // 1) { tandas: [{hour, tandaIndex, role}, ...] }  -> you still need styles from the pattern UI
          // 2) { slots:  [{style, role}, ...] }            -> fully unified
          if (Array.isArray(data?.slots)) {
            state.loadedScheduleSlots = data.slots; // unified
          } else if (Array.isArray(data?.tandas)) {
            // Map {hour, tandaIndex, role} onto current pattern list
            const pattern = getPatternFromUI();
            state.loadedScheduleSlots = data.tandas.map((t, i) => ({
              style: pattern[i] || "Tango",
              role: t.role || DEFAULT_ROLE,
            }));
          }
        });

      // Default if a role is omitted
      const DEFAULT_ROLE = "classic";
      function logAgent(line) {
        const el = document.getElementById("agentLog");
        if (!el) return;
        el.textContent += line + "\n";
        el.scrollTop = el.scrollHeight;
      }
      function fmt(obj) {
        try {
          return JSON.stringify(obj, null, 2);
        } catch {
          return String(obj);
        }
      }
      function normalizeSlots({
        pattern,
        schedule,
        defaultRole = DEFAULT_ROLE,
      }) {
        // Case A: already unified
        if (
          Array.isArray(pattern) &&
          pattern.every((s) => s && typeof s === "object" && s.style)
        ) {
          return pattern.map((s) => ({
            style: s.style,
            role: s.role || defaultRole,
            size: s.size !== undefined ? s.size : s.style === "Tango" ? 4 : 3, // Prioritize explicit size
          }));
        }
        // Case B: legacy pattern + optional schedule[]
        if (
          Array.isArray(pattern) &&
          pattern.every((s) => typeof s === "string")
        ) {
          const roles = Array.isArray(schedule) ? schedule : [];
          return pattern.map((style, i) => ({
            style,
            role: roles[i] || defaultRole,
            size: style === "Tango" ? 4 : 3, // Add explicit size to slots
          }));
        }
        throw new Error(
          "Invalid pattern/schedule; expected array or unified slots."
        );
      }
      function effectiveCortinaGenreFor(ti, blk) {
        const sel = (cortinaGenreSel?.value || "auto").toLowerCase();
        if (sel !== "auto") {
          // Mode 2: When playlist is active, use selected genre for replacements
          console.log(`[CORTINA] Using DJ-selected genre: ${sel}`);
          return sel;
        }
        // Mode 1 & Auto mode: Use existing inference logic
        return deriveCortinaGenre(blk, ti);
      }

      function effectiveTangoGenreFor(ti, blk) {
        const sel = (tangoGenreSel?.value || "auto").toLowerCase();
        if (sel !== "auto") return sel; // DJ-picked genre wins
        return deriveTangoGenre(blk, ti); // your existing inference
      }
      window.addEventListener("load", () => {
        document.getElementById("scheduleSelect").value =
          "tandaScheduleClassic.json";
        document
          .getElementById("scheduleSelect")
          .dispatchEvent(new Event("change"));
      });

      function deriveCortinaGenre(blk, ti) {
        // 1) explicit fields if present
        const explicit =
          blk.genre || blk.cortinaGenre || blk.tags?.genre || blk.styleTag;
        if (explicit && typeof explicit === "string")
          return explicit.trim().toLowerCase();

        // 2) infer from neighbor tanda style (common in milonga programming)
        const left = PLAN?.tandas?.[ti - 1];
        const right = PLAN?.tandas?.[ti + 1];
        const style = (left?.style || right?.style || "").toLowerCase(); // "tango" | "vals" | "milonga" | ...
        if (style) return style;

        // 3) fallback
        return "default";
      }

      function energyOf(t) {
        return t?.tags?.Energy ?? t?.Energy ?? t?.audio?.energy ?? null;
      }
      function getAbsolutePath(file) {
        if (!file) return null;
        return file.absPath || file.id || file.path || file.fullPath || null;
      }
      function getBPM(x) {
        // accept object-level or nested tags/audio; prefer explicit BPM over tempoBPM
        const cands = [
          x?.BPM,
          x?.bpm,
          x?.tempoBPM,
          x?.tags?.BPM,
          x?.tags?.tempoBPM,
          x?.audio?.bpm,
        ];
        for (const v of cands) {
          const n = Number.parseFloat(v);
          if (Number.isFinite(n)) return Math.round(n * 10) / 10;
        }
        return null;
      }
      function bpmOf(t) {
        return getBPM(t);
      } // keep old name if referenced elsewhere

      function isCortinaBlock(blk) {
        if (!blk) return false;
        const style = (blk.style || "").toLowerCase();
        return (
          blk.type === "cortina" ||
          style === "cortina" ||
          (blk.size === 1 &&
            style !== "tango" &&
            style !== "vals" &&
            style !== "milonga")
        );
      }
      // Unified row-click handler: plays tanda tracks and cortinas
      // Unified row-click handler: plays tanda tracks and cortinas
      timelineEl.addEventListener("click", (e) => {
        // Let dedicated button handlers take over if a control was clicked
        if (e.target.closest(".delete-track, .delete-cortina")) return;

        const row = e.target.closest(".track");
        if (!row) return;

        const ti = Number(row.dataset.tandaIndex);
        if (!Number.isFinite(ti)) return;

        // Cortina row behaves like a single-track tanda
        if (row.classList.contains("cortina-track")) {
          curTrackOffset = 0;
          playBlock(ti);
          return;
        }

        // Regular tanda row
        const ki = Number(row.dataset.trackIndex);
        if (!Number.isFinite(ki)) return;
        playSpecific(ti, ki);
      });

      document
        .getElementById("scheduleSelect")
        .addEventListener("change", (e) => {
          const selectedFile = e.target.value;
          if (!selectedFile) return;

          fetch(`/schedules/${selectedFile}`)
            .then((res) => {
              if (!res.ok) {
                throw new Error(
                  `Failed to load schedule: ${res.status} ${res.statusText}`
                );
              }
              return res.json();
            })
            .then((schedule) => {
              console.log("Loaded tanda schedule:", schedule);

              // Try different schedule formats
              const tandas = schedule.tandas || schedule.slots || schedule;
              if (Array.isArray(tandas)) {
                buildPlanFromSchedule(tandas);
              } else {
                console.warn("Schedule format not recognized:", schedule);
              }
            })
            .catch((err) => {
              console.error("Failed to load schedule:", err);
            });
        });

      const DEFAULT_SIZES = { Tango: 4, Vals: 3, Milonga: 3 };

      /** Normalize a single slot record */
      function normalizeSlot(s) {
        const style = String(s.style || "").trim();
        const role = String(s.role || "").trim() || null;
        const size = Number.isFinite(s.size) ? s.size : null;
        if (!style) return null;
        return { style, role, size };
      }

      /** Build slots from legacy arrays (if still present) */
      function slotsFromLegacy(patternArr, scheduleArr) {
        const out = [];
        const N = Array.isArray(patternArr) ? patternArr.length : 0;
        for (let i = 0; i < N; i++) {
          const style = String(patternArr[i] || "").trim();
          if (!style) continue;
          const role = Array.isArray(scheduleArr)
            ? scheduleArr[i] || null
            : null;
          out.push({ style, role, size: null });
        }
        return out;
      }

      /** Parse schedule JSON from file.
       * Accepts:
       *  A) { slots: [{style, role, size?}, ...] }
       *  B) { pattern: [...], tandas: [{tandaIndex, role, ...}, ...] }
       */
      function parseScheduleJSON(json) {
        if (!json || typeof json !== "object") return [];

        // A) Already in slots form
        if (Array.isArray(json.slots) && json.slots.length) {
          return json.slots.map(normalizeSlot).filter(Boolean);
        }

        // B) pattern + tandas (role per index)
        if (Array.isArray(json.pattern) && Array.isArray(json.tandas)) {
          const roleByIndex = new Map();
          for (const t of json.tandas) {
            if (t && Number.isFinite(t.tandaIndex)) {
              roleByIndex.set(t.tandaIndex, (t.role ?? "").trim() || null);
            }
          }
          const slots = json.pattern.map((style, i) => ({
            style: String(style || "").trim(),
            role: roleByIndex.get(i) || null,
            size: null,
          }));
          return slots.filter((s) => s.style);
        }

        // C) Only pattern (no roles)
        if (Array.isArray(json.pattern) && json.pattern.length) {
          return json.pattern
            .map((style) => ({
              style: String(style || "").trim(),
              role: null,
              size: null,
            }))
            .filter((s) => s.style);
        }

        return [];
      }

      /** Merge default sizes into slots (slot.size wins if present) */
      function applySizes(slots, defaultSizes = DEFAULT_SIZES) {
        return slots.map((s) => ({
          ...s,
          size: Number.isFinite(s.size) ? s.size : defaultSizes[s.style] ?? 3,
        }));
      }

      /** MAIN: read slots from a UI <select> or from legacy globals.
       * Returns: { slots, sizes }
       */
      async function readSlotsFromUIorFile({
        scheduleSelectId = "scheduleSelect",
        schedulesBasePath = "/schedules", // change if your files live elsewhere
        defaultSizes = DEFAULT_SIZES,
      } = {}) {
        // 1) If a schedule file is chosen, load & parse it.
        const sel = document.getElementById(scheduleSelectId);
        const fileName = sel && sel.value ? String(sel.value).trim() : "";

        if (fileName) {
          const url = `${schedulesBasePath}/${fileName}`;
          const res = await fetch(url, { cache: "no-store" });
          if (!res.ok) throw new Error(`Failed to load schedule file: ${url}`);
          const json = await res.json();
          const slotsParsed = parseScheduleJSON(json);
          const slots = applySizes(slotsParsed, defaultSizes);
          return { slots, sizes: defaultSizes };
        }

        // 2) Fallbacks:
        //    a) if the page still exposes legacy arrays
        if (Array.isArray(window.PATTERN)) {
          const legacySlots = slotsFromLegacy(window.PATTERN, window.SCHEDULE);
          const slots = applySizes(legacySlots, defaultSizes);
          return { slots, sizes: defaultSizes };
        }

        //    b) last-resort default: 6-slot classic
        const fallback = [
          { style: "Tango", role: "classic" },
          { style: "Tango", role: "classic" },
          { style: "Vals", role: "classic" },
          { style: "Tango", role: "classic" },
          { style: "Tango", role: "classic" },
          { style: "Milonga", role: "classic" },
        ];
        const slots = applySizes(fallback, defaultSizes);
        return { slots, sizes: defaultSizes };
      }
      async function buildGenerateBody() {
        const minutes = Number(getMinutesFromUI() || 180);

        // Read legacy UI controls (if you still show them)
        const pattern = getPatternFromUI(); // e.g., ["Tango","Tango","Vals", ...]
        const schedule = getScheduleRolesFromUI(); // e.g., ["classic","classic","rich", ...] or null

        // Or read a pre-baked unified slots list from a schedule file you loaded:
        // const preBakedSlots = state.loadedScheduleSlots || null;

        const sizes = {
          Tango: Number(getSize("Tango") || 4),
          Vals: Number(getSize("Vals") || 3),
          Milonga: Number(getSize("Milonga") || 3),
        };

        // Prefer unified if provided; otherwise normalize legacy
        const slots = state.loadedScheduleSlots
          ? normalizeSlots({ pattern: state.loadedScheduleSlots })
          : normalizeSlots({ pattern, schedule });

        // Get cortina genre from dropdown (Mode 1: planning)
        const cortinaGenre = cortinaGenreSel?.value || "auto";
        const cortinaGenres =
          cortinaGenre === "auto" ? undefined : [cortinaGenre];

        // keep backward compat for server that still reads 'pattern' (optional):
        return {
          minutes,
          sizes,
          catalog: window.catalogArt, // you already populate this
          slots, // ‚Üê NEW canonical field
          cortinaGenres, // ‚Üê NEW: cortina genre selection
          // pattern, schedule           // (optional) send if server still expects legacy
        };
      }

      async function startStreamingPlan() {
        const body = await buildGenerateBody();

        const res = await fetch("/api/agent/generate/ndjson", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(body),
        });

        // existing NDJSON reader stays the same
        readNdjson(res, onNdjsonEvent);
      }
      const orchestraByRole = {
        classic: [
          { name: "Juan D'Arienzo", era: [1935, 1945] },
          { name: "Rodolfo Biagi", era: [1938, 1944] },
          { name: "Alfredo De Angelis", era: [1940, 1952] },
        ],
        rich: [
          { name: "Anibal Troilo", era: [1940, 1955] },
          { name: "Ricardo Tanturi", era: [1940, 1950] },
          { name: "Carlos Di Sarli", era: [1940, 1958] },
        ],
        modern: [
          { name: "Osvaldo Pugliese", era: [1950, 1970] },
          { name: "Color Tango", era: [1990, 2010] },
          { name: "Sexteto Milonguero", era: [2005, 2020] },
        ],
        alt: [
          { name: "Otros Aires", era: [2005, 2020] },
          { name: "Tanghetto", era: [2005, 2020] },
          { name: "Bajofondo", era: [2002, 2015] },
        ],
      };
      function scoreTrackByRole(track, role, tandaSoFar = []) {
        const year = track.tags?.year ?? 0;
        const artist = (track.tags?.artist || "").toLowerCase();

        const pool = orchestraByRole[role] || [];
        let score = 0;

        for (const entry of pool) {
          const nameMatch = artist.includes(entry.name.toLowerCase());
          const yearMatch = year >= entry.era[0] && year <= entry.era[1];

          if (nameMatch && yearMatch) {
            score += 60;
          } else if (nameMatch) {
            score += 30;
          } else if (yearMatch) {
            score += 20;
          }
        }

        // Penalize repetition within tanda
        if (
          tandaSoFar.some(
            (t) => (t.tags?.artist || "").toLowerCase() === artist
          )
        ) {
          score -= 40;
        }

        return score;
      }
      async function runAgentNDJSON(payload) {
        // payload should include { minutes, catalog, pattern, sizes, tandaScheduleName? / tandaSchedule? }
        logAgent("‚ñ∂ starting agent‚Ä¶");

        const res = await fetch("/api/agent/generate/ndjson", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload),
        });
        if (!res.ok || !res.body) {
          logAgent(`‚úñ HTTP ${res.status} ${res.statusText}`);
          return;
        }

        const reader = res.body.getReader();
        const decoder = new TextDecoder();
        let buf = "";

        try {
          for (;;) {
            const { value, done } = await reader.read();
            if (done) break;
            buf += decoder.decode(value, { stream: true });

            // process complete lines
            let idx;
            while ((idx = buf.indexOf("\n")) >= 0) {
              const line = buf.slice(0, idx).trim();
              buf = buf.slice(idx + 1);
              if (!line) continue;

              let msg;
              try {
                msg = JSON.parse(line);
              } catch {
                logAgent(`(raw) ${line}`);
                continue;
              }

              // Pretty-print a concise line per message type
              switch (msg.type) {
                case "start":
                  logAgent(
                    `‚Ä¢ start  minutes=${msg.minutes}  pattern=[${(
                      msg.pattern || []
                    ).join(", ")}]`
                  );
                  break;
                case "tanda":
                  logAgent(
                    `‚Ä¢ tanda #${msg.index}  style=${msg.tanda?.style}  tracks=${msg.tanda?.tracks?.length}  remainingSec=${msg.remainingSeconds}`
                  );
                  // optional: also update your existing PLAN UI if you want live insertion
                  // insertTandaIntoPlanUI(msg.tanda);  // your existing function
                  break;
                case "summary":
                  logAgent(`‚Ä¢ summary: ${fmt(msg.summary)}`);
                  break;
                case "done":
                  logAgent("‚úì done");
                  // you likely already render plan/timeline; wire it here:
                  // renderPlan(msg.plan); renderTimeline(msg.display.timeline);
                  break;
                case "error":
                  logAgent(`‚úñ error: ${msg.error}`);
                  break;
                default:
                  logAgent(`‚Ä¢ ${msg.type || "event"}: ${fmt(msg)}`);
              }
            }
          }
        } catch (e) {
          logAgent(`‚úñ stream error: ${e?.message || e}`);
        } finally {
          // flush any trailing partial
          const rest = buf.trim();
          if (rest) logAgent(rest);
        }
      }

      function buildTanda(catalog, role, length = 4) {
        const tanda = [];

        // Filter for only tango-related tracks first
        const tangoTracks = catalog.tracks.filter((track) => {
          const genres = track.styles || track.tags?.genre || [];
          const genreList = Array.isArray(genres) ? genres : [genres];

          const hasTangoGenre = genreList.some((genre) => {
            const g = String(genre || "")
              .toLowerCase()
              .trim();
            return (
              g === "tango" || g === "vals" || g === "valse" || g === "milonga"
            );
          });

          // Debug: log non-tango tracks that might be getting through
          if (
            !hasTangoGenre &&
            (track.artist?.toLowerCase().includes("nelson") ||
              track.artist?.toLowerCase().includes("cash"))
          ) {
            console.log(
              `[TANDA] Filtering OUT non-tango track: ${track.artist} - ${
                track.title
              } (genres: ${JSON.stringify(genreList)})`
            );
          }

          return hasTangoGenre;
        });

        console.log(
          `[TANDA] Building ${role} tanda from ${tangoTracks.length} tango tracks (filtered from ${catalog.tracks.length} total)`
        );

        for (let i = 0; i < length; i++) {
          const candidates = tangoTracks
            .map((track) => ({
              track,
              score: scoreTrackByRole(track, role, tanda),
            }))
            .sort((a, b) => b.score - a.score)
            .map((entry) => entry.track);

          const selected = candidates.find((c) => !tanda.includes(c));
          if (selected) {
            // Format the track properly for playback
            const formattedTrack = {
              id: selected.id || selected.absolutePath, // Use existing id or path
              title: selected.title || selected.tags?.title || "Unknown",
              artist: selected.artist || selected.tags?.artist || null,
              album: selected.album || selected.tags?.album || null,
              BPM: selected.BPM || getBPM(selected) || null,
              Energy: selected.Energy || selected.tags?.Energy || null,
              Key: selected.Key || selected.tags?.Key || null,
              camelotKey:
                selected.camelotKey || selected.tags?.camelotKey || null,
              seconds:
                selected.durationSec || selected.format?.durationSec || null,
              absPath:
                selected.absolutePath || getAbsolutePath(selected.file) || null,
            };
            tanda.push(formattedTrack);
          }
        }
        return tanda;
      }

      function buildMilongaSchedule(catalog) {
        const schedule = tandaSchedule.map((entry) => ({
          ...entry,
          tanda: buildTanda(catalog, entry.role),
        }));
        return {
          tandas: schedule.map((e) => ({ style: "Tango", tracks: e.tanda })),
        };
      }

      function buildPlanFromSchedule(tandaSchedule) {
        if (!window.catalogArt || !window.catalogArt.tracks) {
          console.warn("Catalog not yet loaded.");
          return;
        }

        if (!tandaSchedule || !Array.isArray(tandaSchedule)) {
          console.warn("Invalid tanda schedule provided:", tandaSchedule);
          return;
        }
        async function requestReplacement({
          style,
          orchestra,
          position,
          neighbors,
          avoidIds,
          topK = 6,
          homogenize = false,
        }) {
          const body = {
            catalog: window.catalogArt, // <- the *full* catalog you loaded from /catalog-Art.json or /api/catalog/full
            style,
            orchestra: orchestra || null,
            position, // { tandaIndex, trackIndex }
            neighbors, // { prev: { id, BPM, Energy, camelotKey }, next: {...} }
            avoidIds, // array of currently used track ids in this tanda
            topK,
            homogenize,
          };

          const r = await fetch("/api/agent/replace", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(body),
          });

          if (!r.ok) {
            const err = await r.json().catch(() => ({}));
            throw new Error(err?.error || r.statusText);
          }
          return r.json();
        }
        const catalog = window.catalogArt;
        const tandas = tandaSchedule.map((entry, i) => {
          // Handle both old format (entry.role) and new format (entry has style/role)
          const role = entry.role || "classic";
          const style = entry.style || "Tango";
          const tracks = buildTanda(catalog, role, 4); // or 3, 5, etc.
          return {
            style: style.charAt(0).toUpperCase() + style.slice(1), // Capitalize style
            tracks,
          };
        });

        window.PLAN = { tandas };
        renderPlan(); // whatever method you're using to render PLAN into UI
      }

      // event listener for song delete
      timelineEl.addEventListener("click", async (e) => {
        const homogenize = e.shiftKey === true;
        const del = e.target.closest(".delete-track");
        if (!del) return;

        e.preventDefault();
        e.stopPropagation();

        // Ensure we have a catalog for the backend to match against
        if (!window.currentCatalog?.tracks?.length) {
          await prepareCatalog(); // your existing function; sets window.currentCatalog
        }

        const ti = Number(del.dataset.tandaIndex);
        const ki = Number(del.dataset.trackIndex);
        if (!Number.isFinite(ti) || !Number.isFinite(ki) || !PLAN) return;

        const tanda = PLAN.tandas[ti];
        if (!tanda) return;

        // Build context for the agent
        const style = tanda.style;
        const removed = tanda.tracks[ki];
        const orchestra = (removed?.artist || "").trim() || null;

        const neighbor = (d) => {
          const tr = tanda.tracks[ki + d];
          return tr
            ? {
                id: tr.id,
                bpm: tr.BPM ?? null,
                energy: tr.Energy ?? null,
                key: tr.camelotKey ?? tr.Key ?? null,
                artist: tr.artist ?? null,
                seconds: tr.seconds ?? null,
              }
            : null;
        };

        const payload = {
          catalog: window.currentCatalog, // MUST be present
          style,
          orchestra, // prefer to keep same orchestra
          position: { tandaIndex: ti, trackIndex: ki },
          neighbors: { prev: neighbor(-1), next: neighbor(+1) },
          avoidIds: tanda.tracks
            .map((t) => t.id)
            .filter((id, idx) => idx !== ki), // avoid other tracks in this tanda (but not the one being replaced)
          topK: 6, // ask server to propose up to 6 options
          homogenize,
        };

        // Optimistic UI: grey out row while replacing
        const card = document.querySelector(`.card[data-index="${ti}"]`);
        const row = card?.querySelector(`.track[data-track-index="${ki}"]`);
        if (row) row.style.opacity = 0.5;

        try {
          const res = await fetch("/api/agent/replace", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });
          const data = await res.json();
          if (!res.ok) throw new Error(data.error || "Replacement failed");

          // Replace in PLAN and re-render only this tanda
          const repl = data.replacement; // {id,title,artist,...}
          if (!repl?.id) throw new Error("No replacement track returned");

          tanda.tracks.splice(ki, 1, repl);
          // Optional: re-compute approxMinutes for this tanda (if you keep it)
          if (typeof repl.seconds === "number") {
            const secs = tanda.tracks.reduce((s, t) => s + (t.seconds || 0), 0);
            tanda.approxMinutes = Math.max(1, Math.round(secs / 60));
          }
          renderTandaCard(ti); // re-render only this card (helper below)
        } catch (err) {
          console.error(err);
          alert(err.message || String(err));
          if (row) row.style.opacity = 1;
        }
      });
      // --- Cortina replace (single handler; uses replaceCortinaAt) ---
      timelineEl.addEventListener("click", async (e) => {
        const btn = e.target.closest(".delete-cortina");
        if (!btn) return;
        e.preventDefault();
        e.stopPropagation();
        const ti = Number(btn.dataset.index);
        if (!Number.isFinite(ti) || !PLAN) return;

        const blk = PLAN.tandas[ti];
        if (!isCortinaBlock(blk)) return;
        // ‚ûä Resolve genre from selector (or infer if "auto")
        const cortinagenre = effectiveCortinaGenreFor(ti, blk);
        console.log(
          `[CORTINA] Replacing cortina at ${ti} with genre: ${cortinagenre}`
        );

        try {
          // ‚ûå Draw the next item from that genre‚Äôs pool
          const currentId = blk.streamId || blk?.tracks?.[0]?.id || null;
          const repl = await nextCortina(currentId, cortinagenre);

          if (!repl) {
            alert(
              `No alternative cortinas available for genre: ${cortinagenre}`
            );
            return;
          }

          // Normalize the replacement payload for the updater
          const seconds = Number.isFinite(repl.seconds) ? repl.seconds : 60;
          replaceCortinaAt(ti, {
            id: repl.id,
            title: repl.title || "Cortina",
            artist: repl.artist ?? repl.singer ?? null,
            singer: repl.singer ?? null,
            approxMinutes:
              repl.approxMinutes ?? Math.max(1, Math.round(seconds / 60)),
            seconds,
            cortinagenre, // persists on block as cortinaGenre
          });
        } catch (error) {
          console.error(`[CORTINA] Failed to replace cortina:`, error);
          alert(`Failed to replace cortina: ${error.message}`);
        }
      });

      const statusBadge = $("#status-badge");
      const activityLog = $("#activity-log");
      const llmPre = $("#llm-transcript");
      $("#log-clear").onclick = () => (activityLog.textContent = "");
      $("#llm-clear").onclick = () => (llmPre.textContent = "");

      // Orchestra search functionality
      const orchestraSearchInput = $("#orchestra-search");
      const orchestraResults = $("#orchestra-results");
      const orchestraCount = $("#orchestra-count");
      const orchestraTracks = $("#orchestra-tracks");

      $("#orchestra-clear").onclick = () => {
        orchestraSearchInput.value = "";
        orchestraResults.style.display = "none";
      };

      /** Search orchestras and display results */
      function searchOrchestra(searchTerm) {
        if (!searchTerm.trim()) {
          orchestraResults.style.display = "none";
          return;
        }

        if (!window.catalogArt || !window.catalogArt.tracks) {
          orchestraCount.textContent = "Catalog not loaded";
          orchestraTracks.innerHTML = "";
          orchestraResults.style.display = "block";
          return;
        }

        const searchLower = searchTerm.toLowerCase();
        const matchingTracks = window.catalogArt.tracks.filter((track) => {
          const artist = track?.tags?.artist || track?.artist || "";
          return artist.toLowerCase().includes(searchLower);
        });

        orchestraCount.textContent = `Found ${matchingTracks.length} tracks`;

        if (matchingTracks.length === 0) {
          orchestraTracks.innerHTML =
            '<div class="muted">No tracks found</div>';
        } else {
          // Group by artist and show unique orchestras
          const orchestraGroups = {};
          matchingTracks.forEach((track) => {
            const artist = track?.tags?.artist || track?.artist || "Unknown";
            if (!orchestraGroups[artist]) {
              orchestraGroups[artist] = [];
            }
            orchestraGroups[artist].push(track);
          });

          let html = "";
          Object.keys(orchestraGroups)
            .sort()
            .forEach((artist) => {
              const tracks = orchestraGroups[artist];
              html += `<div style="margin-bottom: 12px;">`;
              html += `<div style="font-weight: bold; color: #333; margin-bottom: 4px;">${artist} (${tracks.length} tracks)</div>`;

              tracks.slice(0, 10).forEach((track) => {
                // Show first 10 tracks per orchestra
                const title =
                  track?.tags?.title || track?.title || "Unknown Title";
                const year = track?.tags?.year || "";
                const duration = track?.tags?.duration || "";
                html += `<div style="margin-left: 12px; margin-bottom: 2px; font-size: 0.85em; color: #666;">`;
                html += `${title}`;
                if (year) html += ` (${year})`;
                if (duration) html += ` - ${duration}`;
                html += `</div>`;
              });

              if (tracks.length > 10) {
                html += `<div style="margin-left: 12px; font-size: 0.8em; color: #999;">... and ${
                  tracks.length - 10
                } more tracks</div>`;
              }
              html += `</div>`;
            });

          orchestraTracks.innerHTML = html;
        }

        orchestraResults.style.display = "block";
      }

      // Add search input event listener
      orchestraSearchInput.addEventListener("input", (e) => {
        searchOrchestra(e.target.value);
      });

      /** Status badge (Idle/Busy/OK/Error) */
      function setStatus({ text = "Idle", state = "idle", busy = false } = {}) {
        statusBadge.textContent = text;
        statusBadge.classList.remove("busy", "ok", "err");
        if (state === "ok") statusBadge.classList.add("ok");
        else if (state === "err") statusBadge.classList.add("err");
        else if (busy) statusBadge.classList.add("busy");
      }

      /** Append a line to the activity log */
      function logLine(msg, cls = "") {
        const t = new Date().toLocaleTimeString([], {
          hour: "2-digit",
          minute: "2-digit",
          second: "2-digit",
        });
        const div = document.createElement("div");
        div.innerHTML = `<span class="time">[${t}]</span> <span class="${cls}">${msg}</span>`;
        activityLog.append(div);
        activityLog.scrollTop = activityLog.scrollHeight;
      }

      /** Append to LLM transcript; keeps the last N KB to avoid bloat */
      function appendLLM(text) {
        llmPre.textContent += text;
        if (llmPre.textContent.length > 200_000) {
          llmPre.textContent = llmPre.textContent.slice(-150_000);
        }
        llmPre.scrollTop = llmPre.scrollHeight;
      }
      function setLLM(text) {
        llmPre.textContent = text || "";
      }
      async function fetchWithLog(url, opts = {}, phase = "") {
        if (phase) logLine(`‚Üí ${phase}‚Ä¶`, "phase");
        const res = await fetch(url, opts);
        if (!res.ok) {
          logLine(`‚úñ ${phase} failed (${res.status})`, "err");
        } else if (phase) {
          logLine(`‚úî ${phase} done`, "ok");
        }
        return res;
      }

      function playSpecific(tandaIndex, trackIndex) {
        if (!PLAN) return;
        const blk = PLAN.tandas[tandaIndex];
        if (!blk) return;
        curIdx = tandaIndex;
        curTrackOffset = Math.max(
          0,
          Math.min(trackIndex, (blk.tracks?.length ?? 1) - 1)
        );
        playBlock(curIdx);
      }

      function fmtMin(m) {
        const mins = Math.floor(m),
          secs = Math.round((m - mins) * 60);
        return `${mins}:${String(secs).padStart(2, "0")}`;
      }

      // Helper functions for buildGenerateBody
      function getMinutesFromUI() {
        return $("#minutes")?.value || "180";
      }

      function getPatternFromUI() {
        // Default pattern if not set elsewhere
        return ["Tango", "Tango", "Vals", "Tango", "Tango", "Milonga"];
      }

      function getScheduleRolesFromUI() {
        // Return null to use default roles
        return null;
      }

      function getSize(style) {
        const defaults = { Tango: 4, Vals: 3, Milonga: 3 };
        return defaults[style] || 3;
      }
      function clockAdd(minutes) {
        const d = new Date();
        d.setMinutes(d.getMinutes() + Math.round(minutes));
        return d.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
      }
      function streamUrl(streamId) {
        const encodedId = ensureStreamId(streamId);
        console.log(
          `[STREAM] Original ID: ${streamId?.substring(0, 100)}${
            streamId?.length > 100 ? "..." : ""
          }`
        );
        console.log(
          `[STREAM] Encoded ID: ${encodedId?.substring(0, 100)}${
            encodedId?.length > 100 ? "..." : ""
          }`
        );
        return `/stream/${encodedId}`;
      }
      // --- base64url helpers for /stream/:id ---
      function toB64Url(str) {
        const utf8 = new TextEncoder().encode(str);
        let bin = "";
        for (const b of utf8) bin += String.fromCharCode(b);
        const b64 = btoa(bin)
          .replace(/\+/g, "-")
          .replace(/\//g, "_")
          .replace(/=+$/, "");
        return b64;
      }

      // Track.id might be an absolutePath (needs encoding) or already base64url.
      // Produce a safe stream id either way.
      function ensureStreamId(id) {
        if (!id) return "";

        // If it's already a reasonable base64url (short-ish and no path separators), keep it
        if (
          /^[A-Za-z0-9\-_]+$/.test(id) &&
          !id.includes("/") &&
          id.length < 200
        ) {
          return id;
        }

        // If it's a file path (contains / or \) or very long base64, encode it
        if (id.includes("/") || id.includes("\\") || id.length >= 200) {
          return toB64Url(id);
        }

        // For anything else, encode it to be safe
        return toB64Url(id);
      }

      // ---------- Catalog (for agent endpoints) ----------
      async function fetchCompact(style, maxPages = 2, pageSize = 400) {
        const out = [];
        for (let page = 1; page <= maxPages; page++) {
          const res = await fetch(
            `/api/catalog/compact?style=${encodeURIComponent(
              style
            )}&page=${page}&pageSize=${pageSize}`
          );
          const data = await res.json();
          out.push(
            ...data.tracks.map((t) => ({
              ...t,
              styles: Array.from(new Set([...(t.styles || []), style])),
            }))
          );
          if (page >= data.paging.pages) break;
        }
        return out;
      }

      async function buildAgentCatalog() {
        const tango = await fetchCompact("Tango", 2, 400);
        const vals = await fetchCompact("Vals", 1, 300);
        const milonga = await fetchCompact("Milonga", 1, 300);

        const map = new Map();
        for (const t of [...tango, ...vals, ...milonga]) {
          const k = t.id || getAbsolutePath(t);
          if (!map.has(k)) map.set(k, { ...t });
          else {
            const prev = map.get(k);
            map.set(k, {
              ...prev,
              styles: Array.from(
                new Set([...(prev.styles || []), ...(t.styles || [])])
              ),
            });
          }
        }
        const tracks = [...map.values()];
        return {
          tracks: tracks.map((t) => ({
            id: t.id, // base64url(absolutePath) from /api/catalog/compact
            file: {
              absPath: t.absolutePath, // Use the correct property from /api/catalog/compact
              absolutePath: t.absolutePath, // Also include this for compatibility
            },
            title: t.title,
            artist: t.artist,
            BPM: getBPM(t),
            Energy: t.Energy,
            Key: t.Key,
            camelotKey: t.camelotKey,
            styles: t.styles, // ["Tango"] | ["Vals"] | ["Milonga"]
            artUrl: t.artUrl,
          })),
        };
      }

      async function loadCatalogForPlanner({
        styleCSV = "Tango,Vals,Milonga",
        q = "",
        page = 1,
        pageSize = 500,
      }) {
        const url = `/api/catalog/compact?style=${encodeURIComponent(
          styleCSV
        )}&search=${encodeURIComponent(q)}&page=${page}&pageSize=${pageSize}`;
        const { tracks } = await (await fetch(url)).json();
        return {
          tracks: tracks.map((t) => ({
            id: t.id,
            file: {
              absPath: t.absolutePath, // Use the correct property from /api/catalog/compact
              absolutePath: t.absolutePath, // Also include this for compatibility
            },
            title: t.title,
            artist: t.artist,
            BPM: getBPM(t),
            Energy: t.Energy,
            Key: t.Key,
            camelotKey: t.camelotKey,
            styles: t.styles,
            artUrl: t.artUrl,
          })),
        };
      }

      async function prepareCatalog() {
        // You can preload on page load if you prefer; this is idempotent.
        if (!window.currentCatalog) {
          window.currentCatalog = await loadCatalogForPlanner({
            styleCSV: "Tango,Vals,Milonga",
            q: "",
          });
        }
      }

      const plNameEl = $("#pl-name");
      const plSaveBtn = $("#pl-save");
      const plListSel = $("#pl-list");
      const plRefreshBtn = $("#pl-refresh");
      const plLoadBtn = $("#pl-load");

      function replaceCortinaAt(idx, newC) {
        const seconds = Number.isFinite(newC.seconds) ? newC.seconds : 60;
        const title = newC.title || "Cortina";
        const artist = newC.artist ?? newC.singer ?? null;
        const singer = newC.singer ?? null;

        // Update a single source of truth
        PLAN.tandas[idx] = {
          ...PLAN.tandas[idx],
          type: "cortina", // Fixed: should be "cortina", not "tanda"
          style: "Cortina",
          cortinaGenre:
            newC.cortinagenre || PLAN.tandas[idx]?.cortinaGenre || "default",
          tangoGenre:
            newC.tangogenre || PLAN.tandas[idx]?.tangoGenre || "default",
          size: 1,
          approxMinutes: Math.max(1, Math.round(seconds / 60)),
          title,
          artist,
          singer,
          tracks: [
            {
              id: newC.id,
              title,
              artist,
              seconds,
            },
          ],
          streamId: newC.id,
        };

        // Re-render only this card
        if (typeof renderTandaCard === "function") renderTandaCard(idx);
        else renderPlan();

        if (idx === curIdx) {
          curTrackOffset = 0;
          // Hard reset the element so browsers drop the old buffer
          player.pause();
          player.removeAttribute("src"); // or: player.src = "";
          player.load();
          playBlock(idx);
        }
      }
      // Save current PLAN as a playlist
      async function saveCurrentPlaylist() {
        if (!PLAN || !Array.isArray(PLAN.tandas) || PLAN.tandas.length === 0) {
          alert("No plan to save.");
          return;
        }
        const name =
          (plNameEl.value || "").trim() ||
          `Milonga ${new Date().toLocaleString()}`;
        const res = await fetch("/api/playlists", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ name, plan: PLAN }),
        });
        const data = await res.json();
        if (!res.ok) return alert(data.error || "Save failed");
        alert(`Saved as "${name}"`);
        await refreshPlaylistList();
      }

      // Populate the dropdown with stored playlists
      async function refreshPlaylistList() {
        const res = await fetch("/api/playlists");
        const data = await res.json();
        if (!res.ok) return alert(data.error || "List failed");
        const opts = [`<option value="">‚Äî saved playlists ‚Äî</option>`];
        for (const p of data.playlists || []) {
          const label = `${p.name} ‚Äî ${new Date(p.createdAt).toLocaleString()}`;
          opts.push(`<option value="${p.id}">${label}</option>`);
        }
        plListSel.innerHTML = opts.join("");
      }

      // Load selected playlist (and render)
      async function loadSelectedPlaylist() {
        const id = plListSel.value;
        if (!id) return alert("Select a playlist first.");
        const res = await fetch(`/api/playlists/${encodeURIComponent(id)}`);
        const data = await res.json();
        if (!res.ok) return alert(data.error || "Load failed");

        // Adopt plan & render
        if (!data.plan || !Array.isArray(data.plan.tandas)) {
          return alert("Malformed playlist file.");
        }
        PLAN = data.plan;
        clearReplacementHistory(); // Clear history when loading a new plan
        enrichCortinaMetadataInPlan();

        // Ensure catalog is loaded for replacements
        await ensureCatalogReady();

        curIdx = -1;
        curTrackOffset = 0;
        renderPlan();
        updateCortinaModeIndicator(); // Update mode indicator

        // UI niceties
        const minutesPlanned =
          PLAN.totalMinutes ||
          PLAN.tandas.reduce((m, b) => m + (b.approxMinutes || 0), 0);
        totalEl.textContent = `(${minutesPlanned} min, ${
          PLAN.tandas.filter((x) => x.type === "tanda").length
        } tandas)`;
        etaEl.textContent = clockAdd(minutesPlanned);
        nowEl.textContent = "‚Äì";
        player.src = "";
      }

      // Wire up
      plSaveBtn.onclick = saveCurrentPlaylist;
      plRefreshBtn.onclick = refreshPlaylistList;
      plLoadBtn.onclick = loadSelectedPlaylist;

      // On page load, fetch list once
      refreshPlaylistList();

      // Initialize cortina mode indicator (defensive)
      setTimeout(() => {
        try {
          updateCortinaModeIndicator();
        } catch (error) {
          console.warn("[CORTINA] Failed to initialize mode indicator:", error);
        }
      }, 100);

      // ====== Tanda Library Functions ======

      // Save a tanda to the library
      async function saveTandaToLibrary(tandaIndex, customName = null) {
        if (!PLAN || tandaIndex < 0 || tandaIndex >= PLAN.tandas.length) return;

        const tanda = PLAN.tandas[tandaIndex];
        if (tanda.type !== "tanda") {
          return alert("Can only save tandas, not cortinas");
        }

        const defaultName = `${tanda.orchestra} ${tanda.style}`;
        const name = customName || prompt(`Save tanda as:`, defaultName);
        if (!name) return;

        try {
          const res = await fetch("/api/tandas", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ name, tanda }),
          });

          if (res.ok) {
            const result = await res.json();
            console.log("‚úÖ Tanda saved:", result);
            alert(`Tanda "${name}" saved to library!`);
            await refreshTandaLibrary();
          } else {
            const error = await res.text();
            throw new Error(error);
          }
        } catch (e) {
          console.error("‚ùå Save tanda failed:", e);
          alert(`Failed to save tanda: ${e.message}`);
        }
      }

      // Populate the tanda library dropdown
      async function refreshTandaLibrary() {
        try {
          const res = await fetch("/api/tandas");
          const data = await res.json();
          const select = document.getElementById("tanda-list");

          const opts = [`<option value="">‚Äî saved tandas ‚Äî</option>`];
          for (const t of data.tandas || []) {
            const meta = t.metadata;
            const label = `${t.name} (${t.orchestra}, ${
              meta?.trackCount || 0
            } tracks, ${meta?.approxMinutes || 0}m)`;
            opts.push(`<option value="${t.id}">${label}</option>`);
          }
          select.innerHTML = opts.join("");
        } catch (e) {
          console.error("‚ùå Refresh tanda library failed:", e);
        }
      }

      // Replace current tanda with one from library
      async function loadTandaFromLibrary(tandaIndex) {
        const select = document.getElementById("tanda-list");
        const tandaId = select.value;
        if (!tandaId) return alert("Select a tanda from the library first.");

        if (!PLAN || tandaIndex < 0 || tandaIndex >= PLAN.tandas.length) {
          return alert("Invalid tanda position");
        }

        try {
          const res = await fetch(`/api/tandas/${encodeURIComponent(tandaId)}`);
          if (!res.ok) throw new Error(`HTTP ${res.status}`);

          const data = await res.json();
          if (!data.tanda) throw new Error("Invalid tanda data");

          // Replace the tanda in the plan
          PLAN.tandas[tandaIndex] = {
            type: "tanda",
            orchestra: data.tanda.orchestra,
            style: data.tanda.style,
            tracks: data.tanda.tracks || [],
            approxMinutes: data.tanda.metadata?.approxMinutes || 0,
          };

          renderPlan();
          console.log(
            `‚úÖ Loaded tanda "${data.name}" into position ${tandaIndex}`
          );
          alert(`Loaded "${data.name}" into tanda ${tandaIndex + 1}`);
        } catch (e) {
          console.error("‚ùå Load tanda failed:", e);
          alert(`Failed to load tanda: ${e.message}`);
        }
      }

      // Delete selected tanda from library
      async function deleteSelectedTanda() {
        const select = document.getElementById("tanda-list");
        const tandaId = select.value;
        if (!tandaId) return alert("Select a tanda to delete first.");

        const selectedOption = select.options[select.selectedIndex];
        const tandaName = selectedOption?.text || "selected tanda";

        if (!confirm(`Delete "${tandaName}" from tanda library?`)) return;

        try {
          const res = await fetch(
            `/api/tandas/${encodeURIComponent(tandaId)}`,
            {
              method: "DELETE",
            }
          );

          if (res.ok) {
            console.log(`‚úÖ Deleted tanda ${tandaId}`);
            alert("Tanda deleted from library.");
            await refreshTandaLibrary();
          } else {
            const error = await res.text();
            throw new Error(error);
          }
        } catch (e) {
          console.error("‚ùå Delete tanda failed:", e);
          alert(`Failed to delete tanda: ${e.message}`);
        }
      }

      // Wire up tanda library controls
      const tandaRefreshBtn = document.getElementById("tanda-refresh");
      const tandaDeleteBtn = document.getElementById("tanda-delete");

      tandaRefreshBtn.onclick = refreshTandaLibrary;
      tandaDeleteBtn.onclick = deleteSelectedTanda;

      // Load tanda library on startup
      refreshTandaLibrary();

      function renderTandaCard(ti) {
        if (!PLAN) return;
        const container = timelineEl;
        const old = container.querySelector(`.card[data-index="${ti}"]`);
        if (!old) {
          renderPlan();
          return;
        } // fallback

        const blk = PLAN.tandas[ti];
        enrichCortinaMetadataInPlan();
        const isCortina =
          blk.type === "cortina" ||
          (blk.style || "").toLowerCase() === "cortina";

        const card = document.createElement("div");

        card.className = "card";
        if (isCortina) card.classList.add("cortina");
        card.dataset.index = ti;
        card.dataset.tandaIndex = ti;
        // Unified header
        const hdr = document.createElement("div");
        hdr.className = "row";
        const b = document.createElement("span");
        b.className = isCortina ? "badge" : `badge style-${blk.style}`;
        const trackCount = blk.tracks?.length ?? 1;
        b.textContent = `${isCortina ? "Cortina" : blk.style} ‚Ä¢ ${trackCount} ${
          trackCount === 1 ? "song" : "songs"
        } ‚Ä¢ ~${blk.approxMinutes ?? "?"}m`;
        const g = document.createElement("small");
        g.className = "muted";
        g.style.marginLeft = "8px";
        if (isCortina && blk.cortinaGenre) {
          const genreDisplay =
            blk.cortinaGenre === "default" ? "auto" : blk.cortinaGenre;
          g.textContent = `(${genreDisplay})`;
        }
        if (!isCortina && blk.tangoGenre) g.textContent = `(${blk.tangoGenre})`;
        const buttonsContainer = document.createElement("div");
        buttonsContainer.style.marginLeft = "auto";
        buttonsContainer.style.display = "flex";
        buttonsContainer.style.gap = "4px";

        const swapBtn = !isCortina ? document.createElement("button") : null;
        if (swapBtn) {
          swapBtn.textContent = "Select";
          swapBtn.className = "tiny";
          swapBtn.onclick = () => selectSwap(ti, card);
          buttonsContainer.appendChild(swapBtn);
        }

        // Add Retry Tanda button for problematic tandas
        if (!isCortina) {
          const retryBtn = document.createElement("button");
          retryBtn.textContent = "‚Üª Retry";
          retryBtn.className = "tiny retry-btn";
          retryBtn.title =
            "Regenerate this tanda with different tracks/orchestra";
          retryBtn.onclick = () => retryTanda(ti);

          // Highlight retry button if tanda has issues
          const realTrackCount = (blk.tracks || []).filter(
            (t) => t.id && t.title !== "replace this"
          ).length;
          if (
            realTrackCount === 0 ||
            realTrackCount < (blk.tracks || []).length * 0.5
          ) {
            retryBtn.classList.add("problem");
            retryBtn.title =
              "‚ö† This tanda has missing tracks - click to retry with different selection";
          }

          buttonsContainer.appendChild(retryBtn);

          // Add Save Tanda button
          const saveBtn = document.createElement("button");
          saveBtn.textContent = "üíæ Save";
          saveBtn.className = "tiny";
          saveBtn.title = "Save this tanda to your library";
          saveBtn.onclick = () => saveTandaToLibrary(ti);
          buttonsContainer.appendChild(saveBtn);

          // Add Load Tanda button
          const loadBtn = document.createElement("button");
          loadBtn.textContent = "üìÇ Load";
          loadBtn.className = "tiny";
          loadBtn.title = "Replace this tanda with one from your library";
          loadBtn.onclick = () => loadTandaFromLibrary(ti);
          buttonsContainer.appendChild(loadBtn);
        }

        hdr.append(b, g, buttonsContainer);
        card.append(hdr);

        // Unified tracks loop (cortina has one track)
        const tracksToRender =
          isCortina && (!blk.tracks || blk.tracks.length === 0)
            ? [
                {
                  id: blk.streamId || blk.id,
                  title: blk.title || "Cortina",
                  artist: blk.artist || blk.singer,
                },
              ]
            : blk.tracks || [];

        tracksToRender.forEach((t, k) => {
          const tr = document.createElement("div");
          tr.className = "track" + (isCortina ? " cortina-track" : "");
          tr.dataset.tandaIndex = String(ti);
          tr.dataset.trackIndex = String(isCortina ? 0 : k);
          const metaRight = isCortina
            ? ""
            : `<small>${getBPM(t) ?? ""} bpm ‚Ä¢ ${
                t.camelotKey ?? t.Key ?? ""
              }</small>`;
          const actionBtn = isCortina
            ? `<button type="button" class="tiny danger delete-cortina" data-index="${ti}" title="Replace cortina">‚úï</button>`
            : `<button type="button" class="tiny danger delete-track" data-tanda-index="${ti}" data-track-index="${k}" title="Remove">‚úï</button>`;
          tr.innerHTML = `
                  <div>
                    <div>${t.title}</div>
                    <small class="${isCortina ? "muted" : ""}">${
            t.artist ?? blk.artist ?? ""
          }</small>
                  </div>
                  <div>
                    ${metaRight}
                    ${actionBtn}
                  </div>`;
          tr.style.cursor = "pointer";
          card.append(tr);
        });

        container.replaceChild(card, old);
        // Restore highlight if this tanda is playing
        if (ti === curIdx) highlightNow(ti);
      }

      // ---------- Streaming tanda  agent plan (NDJSON) ----------
      async function streamPlan(payload, onEvent) {
        if (
          !payload?.catalog ||
          !Array.isArray(payload.catalog.tracks) ||
          payload.catalog.tracks.length === 0
        ) {
          throw new Error(
            "No catalog loaded: please load or select tracks first."
          );
        }
        const res = await fetch("/api/agent/generate/ndjson", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload),
        });
        if (!res.ok) throw new Error("Stream failed: " + res.status);

        const reader = res.body.getReader();
        const decoder = new TextDecoder();
        let buf = "";

        while (true) {
          const { value, done } = await reader.read();
          if (done) break;
          buf += decoder.decode(value, { stream: true });

          let nl;
          while ((nl = buf.indexOf("\n")) >= 0) {
            const line = buf.slice(0, nl).trim();
            buf = buf.slice(nl + 1);
            if (!line) continue;
            try {
              const evt = JSON.parse(line);
              onEvent(evt);
            } catch (e) {
              console.warn("bad line:", line, e);
            }
          }
        }
      }
      function findInCortinaPoolById(id) {
        const pool = window.cortinaPool || [];
        if (!id || !pool.length) return null;
        // match by id or streamId
        return pool.find((c) => c?.id === id || c?.streamId === id) || null;
      }

      // If a cortina in PLAN lacks artist/singer, fill from pool
      function enrichCortinaMetadataInPlan() {
        if (!PLAN || !Array.isArray(PLAN.tandas)) return;
        for (const blk of PLAN.tandas) {
          if (!isCortinaBlock(blk)) continue;
          const hasArtist = !!blk.artist;
          const hasSinger = !!blk.singer;
          const id = blk.streamId || blk.id || null;
          if (hasArtist && hasSinger) continue;

          const pooled = findInCortinaPoolById(id);
          if (pooled) {
            if (!hasArtist && pooled.artist) blk.artist = pooled.artist;
            if (!hasSinger && pooled.singer) blk.singer = pooled.singer;
            if (!blk.title && pooled.title) blk.title = pooled.title;
            if (
              !Number.isFinite(blk.approxMinutes) &&
              Number.isFinite(pooled.approxMinutes)
            ) {
              blk.approxMinutes = pooled.approxMinutes;
            }
          }
        }
      }
      // Button handler for ‚ÄúGenerate Tandas (stream tanda by tanda)‚Äù

      async function tandaPlanner() {
        await prepareCatalog(); // gets the catalog for all tracks

        PLAN = { tandas: [], totalMinutes: 0 };
        clearReplacementHistory(); // Clear history when generating new plan
        window.tandaRetryHistory = {}; // Clear retry history for new plan
        timelineEl.innerHTML = "";
        totalEl.textContent = "";
        summaryEl.textContent = "";
        setLLM(""); // clear transcript
        setStatus({ text: "Planning‚Ä¶", busy: true });
        logLine("Starting streamed planning", "phase");

        const minutes = Number($("#minutes").value || 180);
        let built = 0;

        try {
          const body = await buildGenerateBody();
          await streamPlan(body, (evt) => {
            switch (evt.type) {
              case "start":
                summaryEl.textContent = "Planning‚Ä¶";
                logLine("Agent: start");
                break;

              case "llm_delta": // <‚Äî OPTIONAL: if your backend emits token deltas
                appendLLM(evt.text || "");
                break;

              case "llm_message": // <‚Äî OPTIONAL: full chunked message event
                appendLLM((evt.text || "") + "\n");
                break;

              case "tanda":
                built += 1;
                logLine(`Tanda #${built} (${evt.tanda.style}) constructed`);
                const approxMinutes = Math.max(
                  1,
                  Math.round((evt.tanda.seconds || 0) / 60)
                );
                PLAN.tandas.push({
                  type: "tanda",
                  style: evt.tanda.style,
                  size: evt.tanda.tracks.length,
                  approxMinutes,
                  tracks: evt.tanda.tracks.map((t) => ({
                    id: t.id,
                    title: t.title,
                    artist: t.artist,
                    BPM: getBPM(t) ?? t.BPM ?? null,
                    Energy: t.energy ?? t.Energy ?? null,
                    Key: t.key ?? t.Key ?? null,
                    camelotKey: t.camelotKey ?? null,
                  })),
                });
                PLAN.totalMinutes += approxMinutes;
                renderPlan();
                summaryEl.textContent = `Built ${built} tandas‚Ä¶`;
                break;

              case "summary":
                logLine(
                  `Summary: ${evt.summary.tandaCount} tandas, ~${evt.summary.minutesPlanned} minutes`,
                  "ok"
                );
                summaryEl.textContent = `Planned ${evt.summary.tandaCount} tandas; ~${evt.summary.minutesPlanned} minutes.`;
                break;

              case "done": {
                logLine("Planning complete", "ok");

                // The server's DONE payload already includes the interleaved plan (tandas + cortinas).
                // Normalize it (works for both interleaved and split shapes) and adopt it.
                const normalized = normalizePlanResponse(evt);

                if (normalized) {
                  PLAN = normalized;
                  enrichCortinaMetadataInPlan();
                  renderPlan();
                }
                // After setStatus({ text: "Ready", state: "ok" });
                if (Array.isArray(evt.plan?.cortinas)) {
                  setCortinaPool(evt.plan.cortinas);
                  enrichCortinaMetadataInPlan();
                  renderPlan();
                }

                const minutesPlanned =
                  evt.display?.summary?.minutesPlanned ??
                  PLAN?.totalMinutes ??
                  minutes;

                totalEl.textContent = `(${minutesPlanned} min, ${
                  PLAN?.tandas?.filter((x) => x.type === "tanda").length ?? 0
                } tandas)`;
                etaEl.textContent = clockAdd(minutesPlanned);
                setStatus({ text: "Ready", state: "ok" });
                updateCortinaModeIndicator(); // Update mode indicator
                break;
              }

              case "error":
                logLine(`Agent error: ${evt.message || "unknown"}`, "err");
                setStatus({ text: "Error", state: "err" });
                break;

              default:
                // keep unknowns visible for debugging
                if (evt.info) logLine(String(evt.info));
            }
          });
        } catch (e) {
          logLine(`Stream failed: ${e.message || e}`, "err");
          setStatus({ text: "Error", state: "err" });
          alert(e.message || String(e));
        }
      }

      // ---------- Non-stream deterministic planner endpoint ----------
      async function generatePlan() {
        const minutes = Number($("#minutes").value || 180);
        const sizes = {
          Tango: Number(getSize("Tango") || 4),
          Vals: Number(getSize("Vals") || 3),
          Milonga: Number(getSize("Milonga") || 3),
        };
        const res = await fetch("/api/plan", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ minutes, sizes }),
        });
        const data = await res.json();
        if (!res.ok) {
          alert(data.error || "Plan error");
          return;
        }
        PLAN = data.plan;
        clearReplacementHistory(); // Clear history when generating new plan
        curIdx = -1;
        curTrackOffset = 0;
        renderPlan();
        totalEl.textContent = `(${PLAN.totalMinutes} min, ${
          PLAN.tandas.filter((x) => x.type === "tanda").length
        } tandas)`;
        etaEl.textContent = clockAdd(PLAN.totalMinutes);
        nowEl.textContent = "‚Äì";
        player.src = "";
      }
      // Normalize any server response shape into { tandas:[{type:"tanda"| "cortina", ...}], totalMinutes:number }
      function normalizePlanResponse(data) {
        if (!data) return null;
        // 1) Find plan-like payload
        const plan =
          data.plan ??
          (Array.isArray(data.tandas) ? { tandas: data.tandas } : null);
        if (!plan) return null;

        // 2) If already interleaved, just ensure totalMinutes
        if (
          Array.isArray(plan.tandas) &&
          plan.tandas.every((x) => x && x.type)
        ) {
          const total =
            plan.totalMinutes ??
            plan.tandas.reduce((m, b) => m + (b.approxMinutes || 0), 0);
          return { tandas: plan.tandas, totalMinutes: total };
        }

        // 3) If server returned separate arrays (e.g., tandasResolved + cortinas or {tandas: [...], cortinas:[...]})
        const tandasRaw = plan.tandasResolved ?? plan.tandas ?? [];
        const cortinas = plan.cortinas ?? [];

        // If tandasRaw are *just* track arrays (no .type), wrap them
        const tandaBlocks = tandasRaw.map((td) => {
          if (td?.type === "tanda") return td;
          const approxMinutes =
            td?.approxMinutes ??
            (td?.seconds
              ? Math.max(1, Math.round(td.seconds / 60))
              : Math.max(
                  1,
                  Math.round(
                    (td?.tracks?.reduce((s, t) => s + (t?.seconds || 0), 0) ||
                      0) / 60
                  )
                ));
          return {
            type: "tanda",
            style: td?.style ?? "Tango",
            size: td?.size ?? (td?.tracks?.length || 0),
            approxMinutes,
            tracks: (td?.tracks || []).map((t) => ({
              id: t.id,
              title: t.title ?? t?.tags?.title ?? "Unknown",
              artist: t.artist ?? t?.tags?.artist ?? null,
              BPM: t.BPM ?? t?.tags?.BPM ?? t?.tempoBPM ?? null,
              Energy: t.Energy ?? t?.tags?.Energy ?? null,
              Key: t.Key ?? t?.tags?.Key ?? null,
              camelotKey: t.camelotKey ?? t?.tags?.camelotKey ?? null,
              seconds: t.seconds ?? t?.format?.durationSec ?? null,
            })),
          };
        });

        // Interleave cortinas after each tanda if present
        const seq = [];
        let ci = 0;

        for (const td of tandaBlocks) {
          // Add the tanda
          seq.push(td);

          // Add cortina after each tanda (except possibly the last)
          if (cortinas.length && ci < cortinas.length) {
            const c = cortinas[ci];
            const id = c?.id || c?.streamId || c?.tracks?.[0]?.id || null;
            const title = c?.title || c?.tracks?.[0]?.title || "Cortina";
            const artist =
              c?.artist ?? c?.tags?.artist ?? c?.tracks?.[0]?.artist ?? null;
            const seconds = Number.isFinite(c?.seconds)
              ? c.seconds
              : Number.isFinite(c?.tracks?.[0]?.seconds)
              ? c.tracks[0].seconds
              : 60;

            seq.push({
              type: "cortina",
              style: "Cortina",
              size: 1,
              approxMinutes: Number.isFinite(c?.approxMinutes)
                ? c.approxMinutes
                : Math.max(1, Math.round(seconds / 60)),
              title,
              artist,
              singer: c?.singer ?? c?.tags?.singer ?? null,
              tracks: [{ id, title, artist, seconds }],
              streamId: id,
            });
            ci++;
          }
        }

        const totalMinutes =
          plan.totalMinutes ??
          seq.reduce((m, b) => m + (b.approxMinutes || 0), 0);

        return { tandas: seq, totalMinutes };
      }

      // ---------- Timeline rendering & playback ----------
      function renderPlan() {
        timelineEl.innerHTML = "";
        PLAN.tandas.forEach((_, idx) => {
          // create a placeholder so renderTandaCard can replace it
          const placeholder = document.createElement("div");
          placeholder.className = "card";
          placeholder.dataset.index = idx;
          timelineEl.appendChild(placeholder);
          renderTandaCard(idx);
        });
      }

      async function ensureCatalogReady() {
        if (window.currentCatalog?.tracks?.length) {
          console.log(
            `[CATALOG] Already loaded: ${window.currentCatalog.tracks.length} tracks`
          );
          return window.currentCatalog;
        }

        console.log("[CATALOG] Loading catalog for replacement...");
        try {
          // Build the same compact catalog you use for planning
          window.currentCatalog = await loadCatalogForPlanner({
            styleCSV: "Tango,Vals,Milonga",
            q: "",
            page: 1,
            pageSize: 500,
          });
          console.log(
            `[CATALOG] Successfully loaded: ${
              window.currentCatalog?.tracks?.length || 0
            } tracks`
          );

          if (!window.currentCatalog?.tracks?.length) {
            throw new Error("Catalog loaded but contains no tracks");
          }

          return window.currentCatalog;
        } catch (error) {
          console.error("[CATALOG] Failed to load catalog:", error);
          throw error;
        }
      }

      async function openReplacementPicker(tandaIndex, trackIndex) {
        // Make sure we have a catalog ready for the backend
        const catalog = await ensureCatalogReady(); // <-- returns window.currentCatalog

        if (!PLAN) return;
        const tanda = PLAN.tandas[tandaIndex];
        if (!tanda || tanda.type !== "tanda") return;

        // Track being removed
        const removed = tanda.tracks[trackIndex];

        // Debug unknown tracks
        console.log(`[REPLACEMENT] Target track:`, removed);
        console.log(`[REPLACEMENT] All tanda tracks:`, tanda.tracks);

        // Check for missing or problematic data
        if (!removed) {
          throw new Error(
            `No track found at position ${trackIndex} in tanda ${tandaIndex}`
          );
        }

        if (!tanda.style) {
          throw new Error(`Tanda ${tandaIndex} has no style defined`);
        }

        // Prefer same orchestra as the removed track (but ignore "Unknown")
        let orchestra = (removed?.artist || "").trim() || null;
        if (orchestra === "Unknown" || orchestra === "unknown") {
          orchestra = null; // Don't restrict by orchestra for unknown tracks
          console.log(
            `[REPLACEMENT] Ignoring "Unknown" artist for orchestra filtering`
          );
        }

        // Avoid reusing any track already in this tanda
        const avoidIds = tanda.tracks.map((t) => t.id).filter(Boolean);
        console.log(`[REPLACEMENT] Avoid IDs:`, avoidIds);

        // Warn if some tracks don't have IDs
        const tracksWithoutIds = tanda.tracks.filter((t) => !t.id);
        if (tracksWithoutIds.length > 0) {
          console.warn(
            `[REPLACEMENT] Warning: ${tracksWithoutIds.length} tracks in tanda have no ID:`,
            tracksWithoutIds
          );
        }

        // Get replacement session for this position
        const session = getReplacementSession(tandaIndex, trackIndex);
        const previouslySelected = Array.from(session.attempted);

        // Neighbor context (the agent uses this to keep continuity)
        const neighbor = (d) => {
          const tr = tanda.tracks[trackIndex + d];
          return tr
            ? {
                id: tr.id,
                bpm: tr.BPM ?? null,
                energy: tr.Energy ?? null,
                key: tr.camelotKey ?? tr.Key ?? null,
                artist: tr.artist ?? null,
                seconds: tr.seconds ?? null,
              }
            : null;
        };
        const neighbors = { prev: neighbor(-1), next: neighbor(+1) };

        // Build payload
        const payload = {
          catalog, // <-- defined here, not a free variable
          style: tanda.style,
          orchestra,
          position: { tandaIndex, trackIndex },
          neighbors,
          avoidIds,
          previouslySelected, // Include previously selected tracks for broadening
          topK: 5,
        };

        // Debug logging
        console.log(
          `[REPLACEMENT] Request for ${tanda.style} at ${tandaIndex}:${trackIndex}`
        );
        console.log(
          `[REPLACEMENT] Catalog has ${catalog?.tracks?.length || 0} tracks`
        );
        console.log(
          `[REPLACEMENT] Avoiding ${avoidIds.length} tracks:`,
          avoidIds.slice(0, 3)
        );
        console.log(
          `[REPLACEMENT] Previously selected ${previouslySelected.length} tracks:`,
          previouslySelected.slice(0, 3)
        );
        console.log(
          `[REPLACEMENT] Orchestra preference: ${orchestra || "none"}`
        );
        console.log(
          `[REPLACEMENT] Track being replaced:`,
          removed?.id,
          removed?.title,
          removed?.artist
        );

        if (!catalog?.tracks?.length) {
          throw new Error("No catalog available for replacement");
        }

        // Optimistic UI: fade the row while we fetch a replacement
        const card = document.querySelector(
          `.card[data-index="${tandaIndex}"]`
        );
        const row = card?.querySelector(
          `.track[data-track-index="${trackIndex}"]`
        );
        if (row) row.style.opacity = 0.5;

        try {
          const res = await fetch("/api/agent/replace", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });
          const data = await res.json();
          if (!res.ok) throw new Error(data.error || "Replacement failed");

          const repl = data.replacement; // { id,title,artist,BPM,Energy,camelotKey,seconds,... }
          if (!repl?.id) throw new Error("No replacement track returned");

          // Track this replacement in the current session
          session.attempted.add(repl.id);
          console.log(
            `[REPLACEMENT] Added ${repl.id} to session, now avoiding ${session.attempted.size} tracks`
          );

          // Log broadening information if available
          if (data.metadata?.broadeningApplied) {
            console.log(
              `[REPLACEMENT] Broadening was applied for ${tanda.style} track at position ${tandaIndex}:${trackIndex}`
            );
            console.log(
              `[REPLACEMENT] Previously selected: ${previouslySelected.length} tracks`
            );
            console.log(
              `[REPLACEMENT] Pool expanded from ${data.metadata.originalPool} to ${data.metadata.finalPool} tracks`
            );
          }

          // Patch the current plan and refresh only this tanda card
          tanda.tracks.splice(trackIndex, 1, repl);

          // (Optional) recompute tanda ~minutes for display
          const secs = tanda.tracks.reduce((s, t) => s + (t.seconds || 0), 0);
          tanda.approxMinutes = Math.max(1, Math.round(secs / 60));

          // Clear the replacement session since we successfully applied a replacement
          currentReplacementSession = null;
          console.log(
            "[REPLACEMENT] Session cleared after successful replacement"
          );

          // Re-render only this card (falls back to full render if helper missing)
          if (typeof renderTandaCard === "function") {
            renderTandaCard(tandaIndex);
          } else {
            renderPlan();
          }

          // If the replaced row was currently playing, restart that track
          if (
            curIdx === tandaIndex &&
            row &&
            row.classList.contains("playing")
          ) {
            curTrackOffset = Math.min(trackIndex, tanda.tracks.length - 1);
            playBlock(curIdx);
          }
        } catch (err) {
          console.error("[REPLACEMENT] Error:", err);
          console.error("[REPLACEMENT] Failed payload:", payload);

          // Clear session on error to avoid getting stuck
          if (err.message && err.message.includes("No candidates available")) {
            console.log(
              "[REPLACEMENT] Clearing session due to no candidates - may need broader search"
            );
            currentReplacementSession = null;
          }

          let errorMessage = err.message || String(err);
          if (
            errorMessage.includes(
              "None of the catalog tracks matched the library"
            )
          ) {
            errorMessage +=
              "\n\nThis might be due to:\n- Catalog not loaded properly\n- Path format mismatch between frontend and backend\n- Library files moved or renamed";
          }

          alert(errorMessage);
          if (row) row.style.opacity = 1;
        }
      }
      // ---- Cortina pool helpers (rotate through suggestions the server sent) ----
      window.cortinaPool = window.cortinaPool || [];
      window.cortinaIdx = window.cortinaIdx || 0;

      function setCortinaPool(list) {
        window.cortinaPool = Array.isArray(list) ? list.slice() : [];
        window.cortinaIdx = 0;
        console.log(
          `[CORTINA] Pool updated: ${window.cortinaPool.length} cortinas available`
        );
      }

      // Genre-specific cortina pools cache
      window.cortinaPoolsByGenre = window.cortinaPoolsByGenre || {};

      // Fetch cortinas for a specific genre from the server
      async function fetchCortinasByGenre(genre) {
        if (!genre || genre === "auto") {
          genre = "default"; // Use default mix when auto
        }

        // Check if we already have this genre cached
        if (window.cortinaPoolsByGenre[genre]) {
          console.log(
            `[CORTINA] Using cached ${genre} cortinas: ${window.cortinaPoolsByGenre[genre].length} available`
          );
          return window.cortinaPoolsByGenre[genre];
        }

        try {
          console.log(`[CORTINA] Fetching ${genre} cortinas from server...`);

          // Try to get all tracks and filter for non-tango genres
          // This will include jazz, rock, country, blues, etc. from the catalog
          const response = await fetch("/api/catalog/compact?pageSize=1000", {
            method: "GET",
          });

          if (!response.ok) {
            throw new Error(`Failed to fetch cortinas: ${response.status}`);
          }

          const data = await response.json();
          let cortinas = (data.tracks || []).filter((track) => {
            const genres = (track.styles || []).map((s) => s.toLowerCase());
            const isNonTango =
              !genres.includes("tango") &&
              !genres.includes("vals") &&
              !genres.includes("milonga");

            if (genre === "default") {
              return isNonTango; // Return any non-tango for default
            }

            return isNonTango && genres.includes(genre.toLowerCase());
          });

          // If no matches for specific genre, fall back to any non-tango
          if (cortinas.length === 0 && genre !== "default") {
            console.log(
              `[CORTINA] No ${genre} cortinas found, falling back to any non-tango`
            );
            cortinas = (data.tracks || []).filter((track) => {
              const genres = (track.styles || []).map((s) => s.toLowerCase());
              return (
                !genres.includes("tango") &&
                !genres.includes("vals") &&
                !genres.includes("milonga")
              );
            });
          }

          // Transform to cortina format
          const formattedCortinas = cortinas.map((track) => ({
            id: track.absolutePath || track.id, // Use absolutePath (raw file path) instead of encoded id
            title: track.title,
            artist: track.artist,
            genre: genre,
            seconds: track.durationSec || 60,
            approxMinutes: Math.max(
              1,
              Math.round((track.durationSec || 60) / 60)
            ),
          }));

          // Cache the result
          window.cortinaPoolsByGenre[genre] = formattedCortinas;
          console.log(
            `[CORTINA] Cached ${formattedCortinas.length} ${genre} cortinas`
          );

          return formattedCortinas;
        } catch (error) {
          console.error(`[CORTINA] Failed to fetch ${genre} cortinas:`, error);

          // Fallback to existing pool if available
          if (window.cortinaPool && window.cortinaPool.length > 0) {
            console.log(`[CORTINA] Using existing pool as fallback`);
            return window.cortinaPool;
          }

          return [];
        }
      }

      async function nextCortina(excludeId = null, genre = "auto") {
        console.log(
          `[CORTINA] Requesting next cortina for genre: ${genre}, excluding: ${excludeId}`
        );

        // Ensure we have cortinas for the requested genre
        let pool = [];

        if (genre && genre !== "auto") {
          // Get genre-specific pool
          pool = await fetchCortinasByGenre(genre);
        } else {
          // Use existing global pool or fetch default
          pool = window.cortinaPool || [];
          if (!pool.length) {
            pool = await fetchCortinasByGenre("default");
          }
        }

        if (!pool.length) {
          console.warn(`[CORTINA] No cortinas available for genre: ${genre}`);
          return null;
        }

        console.log(
          `[CORTINA] Pool has ${pool.length} cortinas for genre: ${genre}`
        );

        // Filter out the excluded ID
        const available = pool.filter((c) => !excludeId || c.id !== excludeId);

        if (!available.length) {
          console.warn(`[CORTINA] All cortinas excluded for genre: ${genre}`);
          // Return a random one anyway if all are excluded
          return pool[Math.floor(Math.random() * pool.length)];
        }

        // Return a random selection from available cortinas
        const selected =
          available[Math.floor(Math.random() * available.length)];
        console.log(
          `[CORTINA] Selected: ${selected.title} by ${selected.artist}`
        );

        return selected;
      }

      function applyReplacement(tandaIndex, trackIndex, opt) {
        const tanda = PLAN.tandas[tandaIndex];
        if (!tanda || tanda.type !== "tanda") return;

        // Replace in place
        tanda.tracks[trackIndex] = {
          id: opt.id,
          title: opt.title,
          artist: opt.artist,
          BPM: getBPM(opt) ?? null,
          Energy: opt.Energy ?? null,
          Key: null,
          camelotKey: opt.camelotKey ?? null,
        };

        // Remove chooser UI
        const card = timelineEl.querySelector(
          `.card[data-index="${tandaIndex}"]`
        );
        card
          ?.querySelectorAll(".replacement-chooser")
          ?.forEach((el) => el.remove());

        // Re-render timeline to update labels
        renderPlan();

        // If replacing the current playing track inside the current tanda, continue playing this slot
        if (tandaIndex === curIdx) {
          // restart at this track index
          curTrackOffset = trackIndex;
          playBlock(tandaIndex);
        }
      }
      const plDeleteBtn = $("#pl-delete");

      async function deleteSelectedPlaylist() {
        const id = plListSel.value;
        if (!id) {
          alert("Select a playlist to delete.");
          return;
        }
        // Optional: don‚Äôt delete if this is the one currently loaded and unsaved changes exist
        const confirmMsg = `Delete this playlist permanently?\n\n${
          plListSel.selectedOptions[0]?.textContent || id
        }`;
        if (!confirm(confirmMsg)) return;

        const res = await fetch(`/api/playlists/${encodeURIComponent(id)}`, {
          method: "DELETE",
        });
        const data = await res.json();
        if (!res.ok) {
          alert(data.error || "Delete failed");
          return;
        }

        // If you track the currently loaded playlist id, clear it when deleting
        if (window.currentPlaylistId === id) {
          window.currentPlaylistId = null;
        }

        await refreshPlaylistList();
        // Keep the UI usable even if a tanda is selected ‚Äî no relation needed
        alert("Playlist deleted.");
      }

      plDeleteBtn.onclick = deleteSelectedPlaylist;

      function selectSwap(i, card) {
        if (swapFirst === null) {
          swapFirst = i;
          card.classList.add("swapSel");
        } else if (swapFirst === i) {
          swapFirst = null;
          card.classList.remove("swapSel");
        } else {
          const a = swapFirst,
            b = i;
          const A = PLAN.tandas[a],
            B = PLAN.tandas[b];
          if (A.type !== "tanda" || B.type !== "tanda") {
            alert("Select only tandas");
            return;
          }
          [PLAN.tandas[a], PLAN.tandas[b]] = [B, A];
          swapFirst = null;
          document
            .querySelectorAll(".swapSel")
            .forEach((el) => el.classList.remove("swapSel"));
          renderPlan();
        }
      }

      async function retryTanda(tandaIndex) {
        if (!PLAN || tandaIndex < 0 || tandaIndex >= PLAN.tandas.length) return;

        const tanda = PLAN.tandas[tandaIndex];
        if (tanda.type !== "tanda") {
          alert("Can only retry tandas, not cortinas");
          return;
        }

        // Give user options: generate new or load from library
        const choice = prompt(
          `Retry tanda ${tandaIndex + 1} (${tanda.orchestra}):\n\n` +
            `Enter "generate" (or "g") to create a new tanda\n` +
            `Enter "library" (or "l") to load from your tanda library\n` +
            `Press Cancel to abort`,
          "generate"
        );

        if (!choice) return;

        const action = choice.toLowerCase().trim();
        if (action.startsWith("l")) {
          // Load from library
          return loadTandaFromLibrary(tandaIndex);
        } else if (!action.startsWith("g") && action !== "generate") {
          return alert("Please enter 'generate' or 'library'");
        }

        // Continue with generation...

        try {
          // Clear any replacement session for this tanda
          if (window.currentReplacementSession?.tandaIndex === tandaIndex) {
            window.currentReplacementSession = null;
          }

          // Show loading state
          const tandaCard = document.querySelector(
            `[data-tanda-index="${tandaIndex}"]`
          );
          if (tandaCard) {
            tandaCard.style.opacity = "0.6";
            tandaCard.style.pointerEvents = "none";
          }

          setNowLabel(`Retrying tanda ${tandaIndex + 1}...`);

          // Track retry attempts per tanda to cycle through orchestras
          if (!window.tandaRetryHistory) {
            window.tandaRetryHistory = {};
          }

          if (!window.tandaRetryHistory[tandaIndex]) {
            window.tandaRetryHistory[tandaIndex] = {
              originalOrchestra: tanda.orchestra,
              triedOrchestras: [tanda.orchestra], // Include current
              attemptCount: 0,
            };
          }

          const retryHistory = window.tandaRetryHistory[tandaIndex];
          retryHistory.attemptCount++;

          console.log(
            `üîÑ Retry attempt ${retryHistory.attemptCount} for tanda ${
              tandaIndex + 1
            }`
          );
          console.log(
            `üé≠ Previously tried orchestras:`,
            retryHistory.triedOrchestras
          );

          // Prepare the retry request
          // Collect all orchestras currently used in the playlist (excluding the one we're retrying)
          const currentOrchestras = PLAN.tandas
            .filter(
              (t, idx) =>
                idx !== tandaIndex && t.type === "tanda" && t.orchestra
            )
            .map((t) => t.orchestra);

          // Combine previously tried orchestras with orchestras currently used elsewhere in playlist
          const allAvoidOrchestras = [
            ...retryHistory.triedOrchestras,
            ...currentOrchestras,
          ].filter((orch, idx, arr) => orch && arr.indexOf(orch) === idx); // Remove duplicates and nulls

          console.log(`üö´ Avoiding orchestras:`, allAvoidOrchestras);

          const retryData = {
            tandaIndex: tandaIndex,
            currentTanda: {
              orchestra: tanda.orchestra,
              style: tanda.style,
              trackCount: (tanda.tracks || []).length,
            },
            avoidOrchestras: allAvoidOrchestras, // Avoid previously tried + currently used orchestras
            currentPlaylist: PLAN.tandas, // Send current playlist to avoid track duplicates
            catalog: await ensureCatalogReady(),
          };

          const response = await fetch("/api/agent/retryTanda", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(retryData),
          });

          if (!response.ok) {
            throw new Error(
              `Retry failed: ${response.status} ${response.statusText}`
            );
          }

          // Handle streaming NDJSON response
          const reader = response.body.getReader();
          const decoder = new TextDecoder();
          let result = null;

          try {
            while (true) {
              const { done, value } = await reader.read();
              if (done) break;

              const chunk = decoder.decode(value, { stream: true });
              const lines = chunk.split("\n").filter((line) => line.trim());

              for (const line of lines) {
                try {
                  const data = JSON.parse(line);

                  if (data.type === "llm_message") {
                    // Add to LLM transcript
                    appendLLM((data.text || "") + "\n");
                  } else if (data.type === "success") {
                    console.log("üì¶ Received success data:", data);
                    result = data;
                  } else if (data.type === "error") {
                    throw new Error(data.error || "Retry failed");
                  }
                } catch (parseError) {
                  console.warn(
                    "Failed to parse NDJSON line:",
                    line,
                    parseError
                  );
                }
              }
            }
          } finally {
            reader.releaseLock();
          }

          if (!result) {
            throw new Error("No result received from retry");
          }

          console.log(
            `‚úÖ Retry successful for tanda ${tandaIndex + 1}:`,
            result
          );

          console.log(
            "üîç Checking result.success:",
            result.success,
            "result.tanda:",
            result.tanda
          );

          if (result.success && result.tanda) {
            // Track the new orchestra in retry history
            const retryHistory = window.tandaRetryHistory[tandaIndex];
            if (
              retryHistory &&
              !retryHistory.triedOrchestras.includes(result.tanda.orchestra)
            ) {
              retryHistory.triedOrchestras.push(result.tanda.orchestra);
            }

            console.log(
              `‚úÖ New tanda generated with orchestra: ${result.tanda.orchestra}`
            );
            console.log(
              `üé≠ Total orchestras tried for this tanda:`,
              retryHistory?.triedOrchestras || []
            );

            // Replace the problematic tanda
            console.log(
              "üîÑ Before replacement - PLAN.tandas[" + tandaIndex + "]:",
              PLAN.tandas[tandaIndex]
            );
            PLAN.tandas[tandaIndex] = {
              type: "tanda",
              orchestra: result.tanda.orchestra,
              style: result.tanda.style,
              tracks: result.tanda.tracks || [],
            };
            console.log(
              "üîÑ After replacement - PLAN.tandas[" + tandaIndex + "]:",
              PLAN.tandas[tandaIndex]
            );

            // Re-render the plan
            console.log("üé® Calling renderPlan()");
            try {
              renderPlan();
              console.log("‚úÖ renderPlan() completed successfully");
            } catch (renderError) {
              console.error("‚ùå renderPlan() failed:", renderError);
            }

            // Restore card state after successful retry
            const tandaCard = document.querySelector(
              `[data-tanda-index="${tandaIndex}"]`
            );
            if (tandaCard) {
              tandaCard.style.opacity = "1";
              tandaCard.style.pointerEvents = "auto";
            }

            setNowLabel(
              `Tanda ${tandaIndex + 1} successfully regenerated with ${
                result.tanda.orchestra
              }`
            );

            // Success feedback
            setTimeout(() => {
              setNowLabel("Ready");
            }, 3000);
          } else {
            throw new Error(
              result.error || "Retry failed - no tanda generated"
            );
          }
        } catch (error) {
          console.error("‚ùå Retry tanda failed:", error);
          setNowLabel(`Retry failed: ${error.message}`);
          alert(`Failed to retry tanda: ${error.message}`);

          // Restore card state
          const tandaCard = document.querySelector(
            `[data-tanda-index="${tandaIndex}"]`
          );
          if (tandaCard) {
            tandaCard.style.opacity = "1";
            tandaCard.style.pointerEvents = "auto";
          }
        }
      }

      function setNowLabel(text) {
        nowEl.textContent = text;
      }

      async function playBlock(idx) {
        const SERVER_URL = "http://localhost:4000";

        if (!PLAN || idx < 0 || idx >= PLAN.tandas.length) return;

        const blk = PLAN.tandas[idx];
        curIdx = idx;

        const tr = (blk.tracks || [])[curTrackOffset] || (blk.tracks || [])[0];
        if (!tr) return;

        const absPath = getAbsolutePath(tr)?.replace(/\\/g, "/") || "";
        const trFilename = absPath.split("/").pop()?.toLowerCase();
        const catalogArt = window.catalogArt;

        let meta = catalogArt.tracks?.find((x) => {
          const xPath = x?.file?.absPath || x?.file?.absolutePath || "";
          return xPath.replace(/\\/g, "/") === absPath;
        });

        // Fallback if direct path match fails
        if (!meta) {
          meta = catalogArt.tracks?.find((x) => {
            const xPath = x?.file?.absPath || "";
            const xFilename = xPath.split("/").pop()?.toLowerCase();

            const titleMatch =
              (x.tags?.title || "").toLowerCase() ===
              (tr.title || "").toLowerCase();
            const artistMatch =
              (x.tags?.artist || "").toLowerCase() ===
              (tr.artist || "").toLowerCase();

            return xFilename === trFilename && titleMatch && artistMatch;
          });
        }

        if (meta) {
          // meta is the track object found in catalog
          let imgPath =
            meta?.artUrl ?? meta?.tags?.coverUrl ?? meta?.coverUrl ?? null;
          imgPath = imgPath.replace(/\\/g, "/");
          // If it‚Äôs a root-relative path (/album-art/... or /files/...), make it absolute:
          if (imgPath.startsWith("/")) {
            imgPath = SERVER_URL + imgPath;
          }

          if (!window.viewerWin || window.viewerWin.closed) {
            window.viewerWin = window.open(
              "/viewer.html",
              "NowPlaying",
              "width=400,height=600"
            );
          }

          setTimeout(() => {
            window.viewerWin?.postMessage(
              {
                tags: meta,
                artUrl: imgPath,
                role: PLAN.tandas[idx]?.role || null,
              },
              "*"
            );
          }, 300);

          const url = streamUrl(tr.id);
          // robust (re)bind
          player.pause();
          player.src = url;
          player.load(); // ensure the new src is taken
          player.play().catch(() => {});

          const label = isCortinaBlock(blk)
            ? `Cortina ${idx + 1} ‚Äî ${tr.title}`
            : `Tanda ${idx + 1} (${blk.style}) ‚Äî ${tr.title}${
                tr.artist ? " ‚Äî " + tr.artist : ""
              }`;

          setNowLabel(label);
          highlightNow(idx);
        }
      }

      function highlightNow(idx) {
        // Card-level highlight
        document.querySelectorAll(".card").forEach((el, i) => {
          if (i === idx) el.classList.add("now");
          else el.classList.remove("now");
        });

        // Track-row highlight inside the current card
        document
          .querySelectorAll(".track.playing")
          .forEach((el) => el.classList.remove("playing"));
        if (idx >= 0) {
          const card = document.querySelector(`.card[data-index="${idx}"]`);
          const rows = card ? card.querySelectorAll(".track") : [];
          const row = rows[curTrackOffset] || null;
          if (row) {
            row.classList.add("playing");
            // Optional tiny pill ‚ÄúPlaying‚Äù
            if (!row.querySelector(".play-pill")) {
              const pill = document.createElement("span");
              pill.className = "play-pill";
              pill.textContent = "Playing";
              // put it at the right side next to BPM/key (second div)
              row.lastElementChild?.appendChild(pill);
            }
          }
        }
      }

      function next() {
        if (!PLAN) return;
        const blk = PLAN.tandas[curIdx];
        if (blk?.type === "tanda") {
          if (curTrackOffset + 1 < blk.tracks.length) {
            curTrackOffset += 1;
            playBlock(curIdx);
            return;
          } else {
            curTrackOffset = 0;
            if (curIdx + 1 < PLAN.tandas.length) {
              playBlock(curIdx + 1);
              return;
            }
          }
        } else {
          if (curIdx + 1 < PLAN.tandas.length) {
            playBlock(curIdx + 1);
            return;
          }
        }
        setNowLabel("End of plan");
        player.pause();
      }

      // Auto-advance with 5-second delay
      function nextWithDelay() {
        setNowLabel("Next track in 5 seconds...");
        setTimeout(() => {
          next();
        }, 5000); // 5 second delay
      }

      function playPause() {
        if (player.paused) player.play().catch(() => {});
        else player.pause();
      }

      // ========== PLAYLIST REVIEW FUNCTIONS ==========
      function reviewPlaylist(plan) {
        const issues = [];
        const warnings = [];
        const info = [];
        const orchestraAnalysis = {};
        const styleAnalysis = {};
        const tandaDetails = [];

        if (!plan || !Array.isArray(plan.tandas)) {
          issues.push("Invalid playlist structure");
          return {
            issues,
            warnings,
            info,
            score: 0,
            orchestraAnalysis,
            styleAnalysis,
            tandaDetails,
          };
        }

        const tandas = plan.tandas.filter((t) => t.type === "tanda");
        const cortinas = plan.tandas.filter((t) => t.type === "cortina");

        // 1. Check for missing tracks
        let missingTracks = 0;
        let totalTracks = 0;

        tandas.forEach((tanda, idx) => {
          if (!tanda.tracks || tanda.tracks.length === 0) {
            issues.push(`Tanda ${idx + 1} (${tanda.style}) has no tracks`);
            return;
          }

          tanda.tracks.forEach((track, trackIdx) => {
            totalTracks++;
            if (!track.id || !track.title || track.title === "replace this") {
              missingTracks++;
              issues.push(
                `Tanda ${idx + 1}, Track ${
                  trackIdx + 1
                }: Missing or invalid track`
              );
            }
          });

          // Check tanda size expectations
          const expectedSize = tanda.style === "Tango" ? 4 : 3;
          if (tanda.tracks.length < expectedSize) {
            warnings.push(
              `Tanda ${idx + 1} (${tanda.style}) has only ${
                tanda.tracks.length
              } tracks (expected ${expectedSize})`
            );
          }
        });

        // 2. Check cortina placement and coverage
        const totalBlocks = plan.tandas.length;
        const expectedCortinas = Math.max(0, tandas.length - 1); // cortina between each tanda pair

        if (cortinas.length === 0) {
          warnings.push(
            "No cortinas found - dancers won't have breaks between tandas"
          );
        } else if (cortinas.length < expectedCortinas) {
          warnings.push(
            `Only ${cortinas.length} cortinas for ${tandas.length} tandas (expected ~${expectedCortinas})`
          );
        }

        // 3. Check cortina track validity
        cortinas.forEach((cortina, idx) => {
          if (
            !cortina.streamId &&
            (!cortina.tracks || cortina.tracks.length === 0)
          ) {
            issues.push(`Cortina ${idx + 1}: No track assigned`);
          } else if (cortina.tracks && cortina.tracks.length > 0) {
            const track = cortina.tracks[0];
            if (!track.id || !track.title) {
              issues.push(`Cortina ${idx + 1}: Invalid track data`);
            }
          }
        });

        // 4. Check playlist duration and pacing
        const totalMinutes =
          plan.totalMinutes ||
          plan.tandas.reduce(
            (sum, block) => sum + (block.approxMinutes || 0),
            0
          );

        if (totalMinutes < 60) {
          warnings.push(
            `Playlist is quite short (${Math.round(totalMinutes)} minutes)`
          );
        } else if (totalMinutes > 240) {
          warnings.push(
            `Playlist is quite long (${Math.round(totalMinutes)} minutes)`
          );
        }

        // 5. Check style variety
        const styleCount = {};
        tandas.forEach((tanda) => {
          const style = tanda.style || "Unknown";
          styleCount[style] = (styleCount[style] || 0) + 1;
        });

        const styles = Object.keys(styleCount);
        if (styles.length === 1) {
          warnings.push(
            `Only ${styles[0]} tandas - consider adding Vals and Milonga for variety`
          );
        }

        // 6. Check for duplicate tracks
        const trackIds = new Set();
        const duplicates = [];

        tandas.forEach((tanda, tandaIdx) => {
          tanda.tracks?.forEach((track, trackIdx) => {
            if (track.id) {
              if (trackIds.has(track.id)) {
                duplicates.push(`"${track.title}" appears multiple times`);
              } else {
                trackIds.add(track.id);
              }
            }
          });
        });

        if (duplicates.length > 0) {
          warnings.push(...duplicates.slice(0, 5)); // Limit to first 5 duplicates
          if (duplicates.length > 5) {
            warnings.push(`... and ${duplicates.length - 5} more duplicates`);
          }
        }

        // 7. Generate summary info
        info.push(`${tandas.length} tandas, ${cortinas.length} cortinas`);
        info.push(`${totalTracks} total tracks, ${missingTracks} missing`);
        info.push(`~${Math.round(totalMinutes)} minutes total`);

        const stylesSummary = Object.entries(styleCount)
          .map(([style, count]) => `${count} ${style}`)
          .join(", ");
        if (stylesSummary) {
          info.push(`Styles: ${stylesSummary}`);
        }

        // 8. Enhanced Orchestra and Style Analysis
        tandas.forEach((tanda, idx) => {
          const tandaInfo = {
            number: idx + 1,
            style: tanda.style,
            role: tanda.role || "classic",
            tracks: [],
            orchestras: new Set(),
            years: [],
            keys: [],
            bpms: [],
          };

          if (tanda.tracks) {
            tanda.tracks.forEach((track) => {
              if (track.artist) {
                tandaInfo.orchestras.add(track.artist);
                if (!orchestraAnalysis[track.artist]) {
                  orchestraAnalysis[track.artist] = {
                    count: 0,
                    styles: new Set(),
                    roles: new Set(),
                  };
                }
                orchestraAnalysis[track.artist].count++;
                orchestraAnalysis[track.artist].styles.add(tanda.style);
                orchestraAnalysis[track.artist].roles.add(
                  tanda.role || "classic"
                );
              }

              if (track.BPM) tandaInfo.bpms.push(track.BPM);
              if (track.Key) tandaInfo.keys.push(track.Key);

              tandaInfo.tracks.push({
                title: track.title || "Unknown",
                artist: track.artist || "Unknown",
                bpm: track.BPM || null,
                key: track.Key || null,
                camelotKey: track.camelotKey || null,
              });
            });
          }

          // Style analysis
          if (!styleAnalysis[tanda.style]) {
            styleAnalysis[tanda.style] = {
              count: 0,
              roles: new Set(),
              orchestras: new Set(),
              avgBPM: null,
              bpmRange: null,
            };
          }
          styleAnalysis[tanda.style].count++;
          styleAnalysis[tanda.style].roles.add(tanda.role || "classic");
          tandaInfo.orchestras.forEach((orch) =>
            styleAnalysis[tanda.style].orchestras.add(orch)
          );

          // Calculate BPM statistics for this tanda
          if (tandaInfo.bpms.length > 0) {
            const avgBPM =
              tandaInfo.bpms.reduce((sum, bpm) => sum + bpm, 0) /
              tandaInfo.bpms.length;
            tandaInfo.avgBPM = Math.round(avgBPM * 10) / 10;
            tandaInfo.bpmRange = `${Math.min(...tandaInfo.bpms)}-${Math.max(
              ...tandaInfo.bpms
            )}`;
          }

          tandaDetails.push(tandaInfo);
        });

        // Calculate style BPM averages
        Object.keys(styleAnalysis).forEach((style) => {
          const styleTandas = tandaDetails.filter((t) => t.style === style);
          const allBPMs = styleTandas.flatMap((t) => t.bpms);
          if (allBPMs.length > 0) {
            styleAnalysis[style].avgBPM =
              Math.round(
                (allBPMs.reduce((sum, bpm) => sum + bpm, 0) / allBPMs.length) *
                  10
              ) / 10;
            styleAnalysis[style].bpmRange = `${Math.min(...allBPMs)}-${Math.max(
              ...allBPMs
            )}`;
          }
        });

        // Calculate overall score (0-100)
        let score = 100;
        score -= issues.length * 20; // Major issues
        score -= warnings.length * 5; // Minor issues
        score = Math.max(0, Math.min(100, score));

        return {
          issues,
          warnings,
          info,
          score,
          orchestraAnalysis,
          styleAnalysis,
          tandaDetails,
          totalMinutes: Math.round(totalMinutes),
          planName:
            plan.name || `Milonga Plan - ${new Date().toLocaleDateString()}`,
        };
      }

      function generateProgrammaticSummary(review) {
        const {
          issues,
          warnings,
          info,
          score,
          orchestraAnalysis,
          styleAnalysis,
          tandaDetails,
          totalMinutes,
        } = review;

        let summary = `TECHNICAL ANALYSIS SUMMARY:\n`;
        summary += `Overall Score: ${score}/100\n`;
        summary += `Duration: ${totalMinutes} minutes\n`;
        summary += `Issues: ${issues.length} critical, ${warnings.length} warnings\n\n`;

        // Style breakdown
        if (Object.keys(styleAnalysis).length > 0) {
          summary += `STYLE DISTRIBUTION:\n`;
          Object.entries(styleAnalysis).forEach(([style, data]) => {
            summary += `- ${style}: ${data.count} tandas`;
            if (data.avgBPM) summary += ` (avg ${data.avgBPM} BPM)`;
            summary += `\n`;
          });
          summary += `\n`;
        }

        // Orchestra variety
        if (Object.keys(orchestraAnalysis).length > 0) {
          const sortedOrchestras = Object.entries(orchestraAnalysis)
            .sort(([, a], [, b]) => b.count - a.count)
            .slice(0, 10); // Top 10 orchestras
          summary += `TOP ORCHESTRAS:\n`;
          sortedOrchestras.forEach(([orch, data]) => {
            summary += `- ${orch}: ${data.count} tracks (${Array.from(
              data.styles
            ).join(", ")})\n`;
          });
          summary += `\n`;
        }

        // Critical issues
        if (issues.length > 0) {
          summary += `CRITICAL ISSUES:\n`;
          issues.forEach((issue) => (summary += `- ${issue}\n`));
          summary += `\n`;
        }

        // Warnings
        if (warnings.length > 0) {
          summary += `WARNINGS:\n`;
          warnings
            .slice(0, 5)
            .forEach((warning) => (summary += `- ${warning}\n`));
          if (warnings.length > 5)
            summary += `... and ${warnings.length - 5} more warnings\n`;
        }

        return summary;
      }

      function displayEnhancedReviewResults(review) {
        const { issues, warnings, score, aiReview } = review;

        // Quick summary alert with AI enhancement note
        let message = `ü§ñ AI-ENHANCED PLAYLIST REVIEW ü§ñ\n`;
        message += `Overall Score: ${score}/100\n\n`;

        if (issues.length === 0 && warnings.length === 0) {
          message += `‚úÖ EXCELLENT! No issues found.\n`;
          message += `Your playlist looks ready for the milonga! üíÉüï∫\n\n`;
        } else if (issues.length === 0) {
          message += `‚úÖ Good playlist! Only ${warnings.length} minor warnings.\n\n`;
        } else {
          message += `‚ùå ${issues.length} critical issues and ${warnings.length} warnings found.\n\n`;
        }

        message += `‚ú® Includes professional DJ insights from AI analysis\n`;
        message += `Click OK to open detailed review report.`;
        alert(message);

        // Open enhanced detailed review in viewer window
        openEnhancedDetailedReview(review);

        // Also log to console for detailed inspection
        console.log("Enhanced Playlist Review Details:", review);
      }

      function openEnhancedDetailedReview(review) {
        const {
          issues,
          warnings,
          info,
          score,
          orchestraAnalysis,
          styleAnalysis,
          tandaDetails,
          totalMinutes,
          planName,
          aiReview,
          aiMetadata,
        } = review;

        // Open or focus the viewer window
        if (!window.reviewWin || window.reviewWin.closed) {
          window.reviewWin = window.open(
            "/viewer.html",
            "PlaylistReview",
            "width=900,height=1000,scrollbars=yes,resizable=yes"
          );
        }

        // Wait a moment for the window to load, then send the enhanced review data
        setTimeout(() => {
          if (window.reviewWin) {
            const enhancedHTML = generateEnhancedReviewHTML(review);
            window.reviewWin.postMessage(
              {
                type: "review",
                html: enhancedHTML,
                title: `AI-Enhanced Review: ${planName || "Milonga Plan"}`,
              },
              "*"
            );
          }
        }, 500);
      }

      function generateEnhancedReviewHTML(review) {
        const {
          issues,
          warnings,
          info,
          score,
          orchestraAnalysis,
          styleAnalysis,
          tandaDetails,
          totalMinutes,
          planName,
          aiReview,
          aiMetadata,
        } = review;

        let html = `
          <div style="max-width: 100%; padding: 20px; font-family: sans-serif; line-height: 1.6;">
            <h1 style="color: #4CAF50; border-bottom: 2px solid #4CAF50; padding-bottom: 10px;">
              ü§ñ ${planName || "Milonga Plan"} - AI-Enhanced Review
            </h1>`;

        // AI Review Section (prominently featured at the top)
        if (aiReview) {
          html += `
            <div style="background: linear-gradient(135deg, #1a237e 0%, #3949ab 100%); padding: 20px; border-radius: 12px; margin: 20px 0; border: 2px solid #3f51b5;">
              <h2 style="color: #FFD700; margin-top: 0; display: flex; align-items: center; gap: 10px;">
                ‚ú® Professional DJ Analysis (AI-Powered)
                <span style="font-size: 0.6em; background: #FFD700; color: #1a237e; padding: 4px 8px; border-radius: 12px; font-weight: bold;">${
                  aiMetadata?.model || "AI"
                }</span>
              </h2>
              <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 8px; color: #e3f2fd; line-height: 1.8; white-space: pre-wrap; font-size: 1.05em;">
${aiReview}
              </div>
            </div>`;
        }

        html += `
            <div style="background: #2a2a2a; padding: 15px; border-radius: 8px; margin: 20px 0;">
              <h2 style="color: #FFD700; margin-top: 0;">üìä Technical Analysis Overview</h2>
              <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                <div><strong>Overall Score:</strong> ${score}/100</div>
                <div><strong>Total Duration:</strong> ~${totalMinutes} minutes</div>
                <div><strong>Tandas:</strong> ${tandaDetails.length}</div>
                <div><strong>Issues:</strong> ${issues.length} critical, ${warnings.length} warnings</div>
              </div>
            </div>`;

        // Rest of the existing review HTML generation (style analysis, orchestra analysis, etc.)
        // Style Analysis
        if (Object.keys(styleAnalysis).length > 0) {
          html += `
            <div style="background: #2a2a2a; padding: 15px; border-radius: 8px; margin: 20px 0;">
              <h2 style="color: #FFD700; margin-top: 0;">üíÉ Style Analysis</h2>
              <div style="display: grid; gap: 15px;">`;

          Object.entries(styleAnalysis).forEach(([style, data]) => {
            const roles = Array.from(data.roles).join(", ");
            const orchestras = Array.from(data.orchestras)
              .slice(0, 5)
              .join(", ");
            const moreOrchestras =
              data.orchestras.size > 5
                ? ` (+${data.orchestras.size - 5} more)`
                : "";

            html += `
              <div style="border-left: 4px solid #4CAF50; padding-left: 15px;">
                <h3 style="color: #4CAF50; margin: 0 0 8px 0;">${style}</h3>
                <div><strong>Count:</strong> ${data.count} tandas</div>
                <div><strong>Roles:</strong> ${roles}</div>
                ${
                  data.avgBPM
                    ? `<div><strong>BPM:</strong> ${data.avgBPM} avg (${data.bpmRange})</div>`
                    : ""
                }
                <div><strong>Orchestras:</strong> ${orchestras}${moreOrchestras}</div>
              </div>`;
          });

          html += `</div></div>`;
        }

        // Orchestra Analysis
        if (Object.keys(orchestraAnalysis).length > 0) {
          html += `
            <div style="background: #2a2a2a; padding: 15px; border-radius: 8px; margin: 20px 0;">
              <h2 style="color: #FFD700; margin-top: 0;">üéº Orchestra Analysis</h2>
              <div style="display: grid; gap: 10px;">`;

          const sortedOrchestras = Object.entries(orchestraAnalysis).sort(
            ([, a], [, b]) => b.count - a.count
          );

          sortedOrchestras.forEach(([orchestra, data]) => {
            const styles = Array.from(data.styles).join(", ");
            const roles = Array.from(data.roles).join(", ");

            html += `
              <div style="border-left: 3px solid #FF9800; padding-left: 12px; margin: 8px 0;">
                <strong style="color: #FF9800;">${orchestra}</strong>
                <span style="color: #ccc;"> - ${data.count} track${
              data.count > 1 ? "s" : ""
            }</span>
                <div style="font-size: 0.9em; color: #aaa;">
                  Styles: ${styles} | Roles: ${roles}
                </div>
              </div>`;
          });

          html += `</div></div>`;
        }

        // Issues and Warnings
        if (issues.length > 0 || warnings.length > 0) {
          html += `
            <div style="background: #2a2a2a; padding: 15px; border-radius: 8px; margin: 20px 0;">
              <h2 style="color: #FFD700; margin-top: 0;">‚ö†Ô∏è Technical Issues & Recommendations</h2>`;

          if (issues.length > 0) {
            html += `
              <div style="margin: 15px 0;">
                <h3 style="color: #f44336; margin: 0 0 8px 0;">‚ùå Critical Issues</h3>`;
            issues.forEach((issue) => {
              html += `<div style="color: #f44336; margin: 5px 0;">‚Ä¢ ${issue}</div>`;
            });
            html += `</div>`;
          }

          if (warnings.length > 0) {
            html += `
              <div style="margin: 15px 0;">
                <h3 style="color: #ff9800; margin: 0 0 8px 0;">‚ö†Ô∏è Warnings</h3>`;
            warnings.forEach((warning) => {
              html += `<div style="color: #ff9800; margin: 5px 0;">‚Ä¢ ${warning}</div>`;
            });
            html += `</div>`;
          }

          html += `</div>`;
        }

        html += `
            <div style="text-align: center; margin: 30px 0; padding: 20px; background: #1a1a1a; border-radius: 8px;">
              <div style="font-size: 1.2em; color: #4CAF50;">
                AI-Enhanced Review completed at ${new Date().toLocaleString()}
              </div>
              ${
                aiMetadata
                  ? `<div style="color: #999; font-size: 0.9em; margin-top: 8px;">
                Model: ${aiMetadata.model} ‚Ä¢ Tandas: ${
                      aiMetadata.tandaCount
                    } ‚Ä¢ Duration: ${Math.round(aiMetadata.duration / 60)}min
              </div>`
                  : ""
              }
            </div>
          </div>`;

        return html;
      }

      function displayReviewResults(review) {
        const { issues, warnings, info, score } = review;

        // Quick summary alert
        let message = `üéµ PLAYLIST REVIEW REPORT üéµ\n`;
        message += `Overall Score: ${score}/100\n\n`;

        if (issues.length === 0 && warnings.length === 0) {
          message += `‚úÖ EXCELLENT! No issues found.\n`;
          message += `Your playlist looks ready for the milonga! üíÉüï∫\n\n`;
        } else if (issues.length === 0) {
          message += `‚úÖ Good playlist! Only ${warnings.length} minor warnings.\n\n`;
        } else {
          message += `‚ùå ${issues.length} critical issues and ${warnings.length} warnings found.\n\n`;
        }

        message += `Click OK to open detailed review report.`;
        alert(message);

        // Open detailed review in viewer window
        openDetailedReview(review);

        // Also log to console for detailed inspection
        console.log("Playlist Review Details:", review);
      }

      function openDetailedReview(review) {
        const {
          issues,
          warnings,
          info,
          score,
          orchestraAnalysis,
          styleAnalysis,
          tandaDetails,
          totalMinutes,
          planName,
        } = review;

        // Open or focus the viewer window
        if (!window.reviewWin || window.reviewWin.closed) {
          window.reviewWin = window.open(
            "/viewer.html",
            "PlaylistReview",
            "width=800,height=900,scrollbars=yes,resizable=yes"
          );
        }

        // Wait a moment for the window to load, then send the review data
        setTimeout(() => {
          if (window.reviewWin) {
            const reviewHTML = generateReviewHTML(review);
            window.reviewWin.postMessage(
              {
                type: "review",
                html: reviewHTML,
                title: `Review: ${planName}`,
              },
              "*"
            );
          }
        }, 500);
      }

      function generateReviewHTML(review) {
        const {
          issues,
          warnings,
          info,
          score,
          orchestraAnalysis,
          styleAnalysis,
          tandaDetails,
          totalMinutes,
          planName,
        } = review;

        let html = `
          <div style="max-width: 100%; padding: 20px; font-family: sans-serif; line-height: 1.6;">
            <h1 style="color: #4CAF50; border-bottom: 2px solid #4CAF50; padding-bottom: 10px;">
              üéµ ${planName} - Review Report
            </h1>
            
            <div style="background: #2a2a2a; padding: 15px; border-radius: 8px; margin: 20px 0;">
              <h2 style="color: #FFD700; margin-top: 0;">üìä Overview</h2>
              <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                <div><strong>Overall Score:</strong> ${score}/100</div>
                <div><strong>Total Duration:</strong> ~${totalMinutes} minutes</div>
                <div><strong>Tandas:</strong> ${tandaDetails.length}</div>
                <div><strong>Issues:</strong> ${issues.length} critical, ${warnings.length} warnings</div>
              </div>
            </div>`;

        // Style Analysis
        if (Object.keys(styleAnalysis).length > 0) {
          html += `
            <div style="background: #2a2a2a; padding: 15px; border-radius: 8px; margin: 20px 0;">
              <h2 style="color: #FFD700; margin-top: 0;">üíÉ Style Analysis</h2>
              <div style="display: grid; gap: 15px;">`;

          Object.entries(styleAnalysis).forEach(([style, data]) => {
            const roles = Array.from(data.roles).join(", ");
            const orchestras = Array.from(data.orchestras)
              .slice(0, 5)
              .join(", ");
            const moreOrchestras =
              data.orchestras.size > 5
                ? ` (+${data.orchestras.size - 5} more)`
                : "";

            html += `
              <div style="border-left: 4px solid #4CAF50; padding-left: 15px;">
                <h3 style="color: #4CAF50; margin: 0 0 8px 0;">${style}</h3>
                <div><strong>Count:</strong> ${data.count} tandas</div>
                <div><strong>Roles:</strong> ${roles}</div>
                ${
                  data.avgBPM
                    ? `<div><strong>BPM:</strong> ${data.avgBPM} avg (${data.bpmRange})</div>`
                    : ""
                }
                <div><strong>Orchestras:</strong> ${orchestras}${moreOrchestras}</div>
              </div>`;
          });

          html += `</div></div>`;
        }

        // Orchestra Analysis
        if (Object.keys(orchestraAnalysis).length > 0) {
          html += `
            <div style="background: #2a2a2a; padding: 15px; border-radius: 8px; margin: 20px 0;">
              <h2 style="color: #FFD700; margin-top: 0;">üéº Orchestra Analysis</h2>
              <div style="display: grid; gap: 10px;">`;

          const sortedOrchestras = Object.entries(orchestraAnalysis).sort(
            ([, a], [, b]) => b.count - a.count
          );

          sortedOrchestras.forEach(([orchestra, data]) => {
            const styles = Array.from(data.styles).join(", ");
            const roles = Array.from(data.roles).join(", ");

            html += `
              <div style="border-left: 3px solid #FF9800; padding-left: 12px; margin: 8px 0;">
                <strong style="color: #FF9800;">${orchestra}</strong>
                <span style="color: #ccc;"> - ${data.count} track${
              data.count > 1 ? "s" : ""
            }</span>
                <div style="font-size: 0.9em; color: #aaa;">
                  Styles: ${styles} | Roles: ${roles}
                </div>
              </div>`;
          });

          html += `</div></div>`;
        }

        // Detailed Tanda Breakdown
        if (tandaDetails.length > 0) {
          html += `
            <div style="background: #2a2a2a; padding: 15px; border-radius: 8px; margin: 20px 0;">
              <h2 style="color: #FFD700; margin-top: 0;">üìù Tanda Details</h2>`;

          tandaDetails.forEach((tanda) => {
            const orchestras =
              Array.from(tanda.orchestras).join(", ") || "Various";

            html += `
              <div style="border: 1px solid #444; border-radius: 6px; padding: 12px; margin: 12px 0;">
                <h3 style="color: #4CAF50; margin: 0 0 8px 0;">
                  Tanda ${tanda.number}: ${tanda.style} (${tanda.role})
                </h3>
                <div style="margin-bottom: 8px;">
                  <strong>Orchestras:</strong> ${orchestras}
                  ${
                    tanda.avgBPM
                      ? `<br><strong>BPM:</strong> ${tanda.avgBPM} avg (${tanda.bpmRange})`
                      : ""
                  }
                </div>
                <div style="margin-left: 15px;">`;

            tanda.tracks.forEach((track, idx) => {
              html += `
                <div style="margin: 4px 0; color: #ccc;">
                  ${idx + 1}. ${track.title} - ${track.artist}
                  ${track.bpm ? ` (${track.bpm} BPM)` : ""}
                  ${track.key ? ` [${track.key}]` : ""}
                </div>`;
            });

            html += `</div></div>`;
          });

          html += `</div>`;
        }

        // Issues and Warnings
        if (issues.length > 0 || warnings.length > 0) {
          html += `
            <div style="background: #2a2a2a; padding: 15px; border-radius: 8px; margin: 20px 0;">
              <h2 style="color: #FFD700; margin-top: 0;">‚ö†Ô∏è Issues & Recommendations</h2>`;

          if (issues.length > 0) {
            html += `
              <div style="margin: 15px 0;">
                <h3 style="color: #f44336; margin: 0 0 8px 0;">‚ùå Critical Issues</h3>`;
            issues.forEach((issue) => {
              html += `<div style="color: #f44336; margin: 5px 0;">‚Ä¢ ${issue}</div>`;
            });
            html += `</div>`;
          }

          if (warnings.length > 0) {
            html += `
              <div style="margin: 15px 0;">
                <h3 style="color: #ff9800; margin: 0 0 8px 0;">‚ö†Ô∏è Warnings</h3>`;
            warnings.forEach((warning) => {
              html += `<div style="color: #ff9800; margin: 5px 0;">‚Ä¢ ${warning}</div>`;
            });
            html += `</div>`;
          }

          html += `</div>`;
        }

        html += `
            <div style="text-align: center; margin: 30px 0; padding: 20px; background: #1a1a1a; border-radius: 8px;">
              <div style="font-size: 1.2em; color: #4CAF50;">
                Review completed at ${new Date().toLocaleString()}
              </div>
            </div>
          </div>`;

        return html;
      }

      function startPlan() {
        if (!PLAN) return;
        curTrackOffset = 0;
        let idx = 0;
        if (isCortinaBlock(PLAN.tandas[0]) && PLAN.tandas.length > 1) idx = 1;
        idx = 1;
        playBlock(idx);
      }

      // Timeline counters
      setInterval(() => {
        if (!PLAN) {
          elapsedEl.textContent = "0:00";
          remainingEl.textContent = "0:00";
          return;
        }
        const audioT = isFinite(player.currentTime) ? player.currentTime : 0;
        let priorMin = 0;
        for (let i = 0; i < PLAN.tandas.length; i++) {
          if (i < curIdx) priorMin += PLAN.tandas[i].approxMinutes || 0;
          else break;
        }
        const currMin = audioT / 60;
        const elapsed = priorMin + currMin;
        const remaining = Math.max(0, (PLAN.totalMinutes || 0) - elapsed);
        elapsedEl.textContent = fmtMin(elapsed);
        remainingEl.textContent = fmtMin(remaining);
      }, 1000);

      // Events & buttons
      player.addEventListener("ended", nextWithDelay);
      $("#tanda-gen").onclick = tandaPlanner;
      $("#review").onclick = async () => {
        if (!PLAN) {
          alert("No playlist to review. Generate or load a playlist first.");
          return;
        }

        // First, show loading message
        alert(
          "ü§ñ Generating comprehensive playlist review...\nThis includes both technical analysis and AI-powered DJ insights.\n\nPlease wait a moment while the AI reviews your selection."
        );

        try {
          // Clear and start LLM transcript for AI review
          setLLM("");
          appendLLM("ü§ñ AI PLAYLIST REVIEW STARTED\n");
          appendLLM("=".repeat(50) + "\n");
          appendLLM(
            `üìã Analyzing playlist: ${PLAN.tandas.length} tandas, ${Math.round(
              PLAN.duration / 60
            )} minutes\n\n`
          );

          // 1. Get programmatic analysis
          appendLLM("üîç Step 1: Running technical analysis...\n");
          const programmaticReview = reviewPlaylist(PLAN);
          appendLLM("‚úÖ Technical analysis complete\n\n");

          // 2. Prepare programmatic analysis as text for the AI
          appendLLM("üìù Step 2: Preparing data for GPT-4o agent...\n");
          const programmaticSummary =
            generateProgrammaticSummary(programmaticReview);
          appendLLM(
            `üìä Technical summary: ${programmaticSummary.length} characters\n\n`
          );

          // 3. Call AI review endpoint
          appendLLM("üöÄ Step 3: Calling GPT-4o playlist review agent...\n");
          appendLLM("‚è≥ Waiting for AI response...\n\n");

          const aiResponse = await fetch("/api/agent/review", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              playlist: PLAN,
              programmaticAnalysis: programmaticSummary,
            }),
          });

          if (!aiResponse.ok) {
            throw new Error(
              `AI Review failed: ${aiResponse.status} ${aiResponse.statusText}`
            );
          }

          const aiResult = await aiResponse.json();

          if (!aiResult.success) {
            appendLLM("‚ùå AI review failed: " + aiResult.error + "\n");
            throw new Error(aiResult.error || "AI review failed");
          }

          appendLLM("‚úÖ GPT-4o response received!\n");
          appendLLM(`üìä Model: ${aiResult.metadata?.model || "GPT-4o"}\n`);
          appendLLM(
            `üìù Review length: ${
              aiResult.metadata?.reviewLength || 0
            } characters\n\n`
          );

          // Display the actual agent interaction like in streaming mode
          if (aiResult.agentInteraction) {
            appendLLM("ü§ñ GPT-4o AGENT INTERACTION:\n");
            appendLLM("‚îÄ".repeat(60) + "\n");
            appendLLM("üì§ PROMPT TO AGENT:\n");
            appendLLM(aiResult.agentInteraction.prompt + "\n\n");

            appendLLM("üì• RAW AGENT RESPONSE:\n");
            if (aiResult.agentInteraction.rawResponse) {
              const rawResp =
                typeof aiResult.agentInteraction.rawResponse === "object"
                  ? JSON.stringify(
                      aiResult.agentInteraction.rawResponse,
                      null,
                      2
                    )
                  : aiResult.agentInteraction.rawResponse;
              appendLLM(rawResp + "\n\n");
            }
            appendLLM("‚îÄ".repeat(60) + "\n\n");
          }

          appendLLM("üéØ PROFESSIONAL DJ ANALYSIS:\n");
          appendLLM("‚îÄ".repeat(40) + "\n");
          appendLLM(aiResult.review + "\n");
          appendLLM("‚îÄ".repeat(40) + "\n\n");

          appendLLM("‚ú® AI REVIEW COMPLETE - Opening detailed view...\n");
          appendLLM("=".repeat(50) + "\n");

          // 4. Combine both analyses and display enhanced results
          const enhancedReview = {
            ...programmaticReview,
            aiReview: aiResult.review,
            aiMetadata: aiResult.metadata,
          };

          displayEnhancedReviewResults(enhancedReview);
        } catch (error) {
          console.error("Review error:", error);

          appendLLM(`\n‚ùå ERROR: ${error.message}\n`);
          appendLLM("üîÑ Falling back to basic technical analysis only...\n");
          appendLLM("=".repeat(50) + "\n");

          alert(
            `‚ùå Review failed: ${error.message}\n\nFalling back to basic analysis...`
          );

          // Fallback to programmatic review only
          const review = reviewPlaylist(PLAN);
          displayReviewResults(review);
        }
      };
      $("#swap").onclick = () => {
        if (swapFirst === null)
          alert("Click 'Select' on two tanda cards to swap.");
      };
      $("#next").onclick = next;
      $("#pause").onclick = playPause;

      // Auto-generate deterministic plan on load; then you can start playback
      generatePlan().then(startPlan);

      // Expose tanda Planner globally for the header button's onclick
      window.tandaPlanner = tandaPlanner;
    </script>
  </body>
</html>
